import ("std")

const ARGPARSE_NO_VERBOSE                   = 1 << 0
const ARGPARSE_DONOT_EXIT_ON_UNKNOWN        = 1 << 1
const ARGPARSE_DONOT_PRINT_AND_EXIT_ON_HELP = 1 << 2
const ARGPARSE_SHORT_H_ISNOT_HELP           = 1 << 3

const ARG_VALUE_REQUIRED  = 1 << 0
const ARG_VALUE_OPTIONAL  = 1 << 1
const ARG_LITERAL         = 1 << 2
const ARG_VALUE_APPEND    = 1 << 3

Type Argparse {
private
  "idx"
  "curidx"
  "maxlen"
  "verbose"
  "exit_on_unknown"
  "print_and_exit_on_help"
  "short_h_is_help"
  "types"
  "flags"
  "as"
  "shortopts"
  "longopts"
  "descr"
  "message"

  "init" : func (num_options, flags, message) {
    this.idx = -1
    this.curidx = -1
    this.maxlen =  2
    this.argv = null
    this.argc = 0
    this.input_argc  = 0
    this.input_argv  = null
    this.err_message = ""
    this.results   = {}
    this.message   = message
    this.types     = integer[num_options]
    this.flags     = integer[num_options]
    this.as        = string[num_options]
    this.shortopts = integer[num_options]
    this.longopts  = string[num_options]
    this.descr     = string[num_options]
    this.verbose                = (flags & ARGPARSE_NO_VERBOSE is 0)
    this.exit_on_unknown        = (flags & ARGPARSE_DONOT_EXIT_ON_UNKNOWN is 0)
    this.print_and_exit_on_help = (flags & ARGPARSE_DONOT_PRINT_AND_EXIT_ON_HELP is 0)
    this.short_h_is_help        = (flags & ARGPARSE_SHORT_H_ISNOT_HELP is 0)
    this.exit = false
  }

  "parse_literal_arg" : func (arg) {
    for |j, opt| in this.longopts {
      if (null isnot opt and opt: len ()) {
        if (opt: eq (arg)) {
          var type = this.types[j]
          var as = this.as[j]
          var flags = this.flags[j]

          if (flags & ARG_LITERAL) {
            if (type is IntegerType or type is BooleanType) {
              this.results.$(as) = true
              this.flags[j] &= ~ARG_LITERAL;
              return true
            }
          }

          return false
        }
      }
    }
    return false
  }

  "parse_short_arg" : func (arg) {
    String.advance (arg, 1)

    var retval = false

    for |c| in arg {
      if (c is 'h') {
        if (this.short_h_is_help) {
          if (this.print_and_exit_on_help) {
            this.print_description ()
            this.exit = true
            return ok
          }
        }
      }

      retval = false
      for |j, opt| in this.shortopts {
        if (opt) {
          continue if (c isnot opt)

          retval = true
          var type = this.types[j]
          var as = this.as[j]
          var flags = this.flags[j]

          if (type is IntegerType and flags & ARG_VALUE_APPEND) {
            this.results.$(as)++
            # or more verbose
            # Map.set (this.results, as, this.results: get (as) + 1);
            break
          }

          if (type is BooleanType) {
            this.results.$(as) = true
          } else {
            if (flags & (ARG_VALUE_REQUIRED|ARG_VALUE_OPTIONAL)) {
              if (this.curidx is this.input_argc - 1 or
                  this.input_argv[this.curidx + 1][0] is '-') {
                if (flags & ARG_VALUE_REQUIRED) {
                  if this.verbose is true then
                    println (stderr, "error ${%s, arg) argument awaits a value")
                  orelse
                    this.err_message = format ("error ${%s, arg) argument awaits a value")

                  return notok
                }

                this.results.$(as) = 
                  if type is IntegerType or type is BooleanType then true
                  orelse if type is StringType then ""

                break
              }
            }

            this.curidx++

            this.results.$(as) = 
              if type is IntegerType then this.input_argv[this.curidx]: to_integer ()
              orelse if type is StringType then this.input_argv[this.curidx]
          }

          break
        }
      }

      if (retval is false) {
        if (this.exit_on_unknown) {
          if (this.verbose) {
            println ("-${c: char ()}: unknown argument")
            this.print_description ()
          }

          return notok
        }
      }
    }

    return retval
  }

  "parse_opt_val" : func (flags, type, as) {
    if (flags & ARG_VALUE_APPEND) {
      flags &= ~ARG_VALUE_OPTIONAL
      flags |= ARG_VALUE_REQUIRED
    }

    if (this.curidx is this.input_argc - 1 or
       this.input_argv[this.curidx + 1][0] is '-') {
      if (flags & ARG_VALUE_REQUIRED) {
        if this.verbose is true then
          println (stderr, "error ${arg) argument awaits a value")
        orelse
          this.err_message = format ("error ${arg) argument awaits a value")

        return notok
      }

      this.results.$(as) = 
        if type is IntegerType or type is BooleanType then true
        orelse if type is StringType then ""

      return true
    }

    this.curidx++

    if (type is IntegerType) {
      this.results.$(as) = this.input_argv[this.curidx]: to_integer ()
    } else if (type is BooleanType) {
      this.results.$(as) = this.input_argv[this.curidx]:
          to_integer (): if x < 0 or x > 1 then false orelse true end
    } else if (type is StringType) {
       this.results.$(as) = this.input_argv[this.curidx]
    } else if (type is ListType) {
      if this.results.$(as) is null then
         this.results.$(as) = list_new ()

      list_append (this.results.$(as), this.input_argv[this.curidx])
    }

    return true
  }

  "parse_long_arg" : func (arg) {
    if (arg is "--help") {
      if (this.print_and_exit_on_help) {
        this.print_description ()
        this.exit = true
        return 1
      }
    }

    var found = false
    for |j, opt| in this.longopts {
      if (null isnot opt and opt: len ()) {
        var long = "--" + opt
        var long_len = long: len ()

        if (long: eq_n (arg, long_len)) {
          var type = this.types[j]
          var as = this.as[j]
          var flags = this.flags[j]

          continue if (flags & ARG_LITERAL)

          found = true
          ifnot (flags) {
            this.results.$(as) = 
              if type is IntegerType or type is BooleanType then true
              orelse if type is StringType then ""

            return true
          }

          if long[-1] isnot '=' then
            return this.parse_opt_val (flags, type, as)

          var optval = arg: byte_in_str ('=')
          var vallen = optval: len ()

          String.advance (optval, 1);
          if (vallen is optval: len ()) {
            if (flags & ARG_VALUE_REQUIRED) {
              if this.verbose is true then
                println (stderr, "error ${arg) argument requires a value")
              orelse
                this.err_message = format ("error ${arg) requires a value")

              return notok

            }

            this.results.$(as) = 
              if type is IntegerType or type is BooleanType then true
              orelse if type is StringType then ""

            return true
          }

          this.results.$(as) =
            if type is BooleanType then
              optval: to_integer (): if x isnot false then true orelse false end
            orelse
              if type is IntegerType then
                optval: to_integer ()
              orelse
                if type is StringType then optval

          break
        }
      }
    }

    if (found is false) then this.argv[this.argc++] = arg

    return found
  }

public

  "add" : func (as, short, long, descr, type, flags) {
    this.idx++
    this.shortopts[this.idx] = short
    this.longopts[this.idx]  = long
    this.as[this.idx]        = as
    this.types[this.idx]     = type
    this.flags[this.idx]     = flags
    this.descr[this.idx]     = descr

    this.results.$(as) =
      if type is IntegerType or type is BooleanType
        then false orelse null

    ifnot (null is long) {
      var llen = long: len ()
      if llen > this.maxlen then this.maxlen = llen
    }
  }

  "print_description" : func {
    var msg = format ("Usage: ${%s, this.message} \n\n")
    var arlen = this.shortopts: len ()

    for (var i = 0; i < arlen; i++) {
      var slen = 0
      var is_short = 0

      if (this.shortopts[i]) {
        msg += "  -" + this.shortopts[i]
        slen += 2
        is_short = 1
      }

      var is_long = 0
      var llen = 0
      var is_literal = 0

      if (null isnot this.longopts[i]) {
        llen = this.longopts[i]: len ()
        if (llen) {
          is_long = 1
          is_literal = this.flags[i] & ARG_LITERAL

          if (is_short) {
            ifnot is_literal then msg += ",--" orelse msg += ","
            slen++
          } else {
            ifnot is_literal then msg += "  --" orelse msg += "  "
          }

          msg += this.longopts[i]
        }
      }

      continue ifnot (is_short + is_long)

      var first = this.maxlen + 5
      var num_spaces = first - (llen + slen)

      if llen then ifnot is_literal then num_spaces -= 2

      loop (num_spaces) msg += ' '

      msg += "  " + this.descr[i] + "\n"
    }

    println (msg)
  }

  "process" : func (argv, start) {
    var argc = len (argv)
    this.argv = string[argc]
    this.argc = 0
    this.input_argc = argc
    this.input_argv = argv

    var retval = false

    for (this.curidx = 0; this.curidx < argc; this.curidx++) {
      continue if (this.curidx < start)

      var arg = argv[this.curidx]

      if (arg is "--") {
        for (var j = this.curidx + 1; j < argc; j++)
          this.argv[this.argc++] = this.input_argv[j]

        return ok
      }

      if (arg[0] isnot '-') {
        continue if true is this.parse_literal_arg (arg)

        this.argv[this.argc++] = arg
        continue
      }

      retval = false

      ifnot arg: len () - 1 then return notok # for now

      if arg[1] isnot '-' {
        retval = this.parse_short_arg (arg)

        return notok if retval is notok

        return ok if this.exit is true

        continue
      }

      retval = this.parse_long_arg (arg)

      return notok if retval is notok

      if (retval is false) {
        if (this.exit_on_unknown) {
          if (this.verbose) {
            println ("${%s, arg}: unknown argument")
            this.print_description ()
          }

          return notok
        }
      }

      return ok if this.exit is true
    }

    return ok
  }
}
