import ("std")

const ARGPARSE_NO_VERBOSE                   = 1 << 0
const ARGPARSE_DONOT_EXIT_ON_UNKNOWN        = 1 << 1
const ARGPARSE_DONOT_PRINT_AND_EXIT_ON_HELP = 1 << 2
const ARGPARSE_SHORT_H_ISNOT_HELP           = 1 << 3

const ARG_VALUE_REQUIRED  = 1 << 0
const ARG_VALUE_OPTIONAL  = 1 << 1
const ARG_VALUE_NO_DASH   = 1 << 2
const ARG_VALUE_APPEND    = 1 << 3

Type Argparse {
private
  "idx"
  "curidx"
  "maxlen"
  "verbose"
  "exit_on_unknown"
  "print_and_exit_on_help"
  "short_h_is_help"
  "types"
  "flags"
  "as"
  "shortopts"
  "longopts"
  "descr"
  "message"

  "init" : func (num_options, flags, message) {
    this.idx = -1
    this.curidx = -1
    this.maxlen =  2
    this.argv = null
    this.argc = 0
    this.input_argc  = 0
    this.input_argv  = null
    this.err_message = ""
    this.results   = {}
    this.message   = message
    this.types     = integer[num_options]
    this.flags     = integer[num_options]
    this.as        = string[num_options]
    this.shortopts = integer[num_options]
    this.longopts  = string[num_options]
    this.descr     = string[num_options]
    this.verbose                = (flags & ARGPARSE_NO_VERBOSE is 0)
    this.exit_on_unknown        = (flags & ARGPARSE_DONOT_EXIT_ON_UNKNOWN is 0)
    this.print_and_exit_on_help = (flags & ARGPARSE_DONOT_PRINT_AND_EXIT_ON_HELP is 0)
    this.short_h_is_help        = (flags & ARGPARSE_SHORT_H_ISNOT_HELP is 0)
    this.exit = false
  }

  "parse_short_arg" : func (arg) {
    String.advance (arg, 1)

    var retval = false

    for |c| in arg {
      if (c is 'h') {
        if (this.short_h_is_help) {
          if (this.print_and_exit_on_help) {
            this.print_description ()
            this.exit = true
            return ok
          }
        }
      }

      retval = false
      for |j, opt| in this.shortopts {
        if (opt) {
          continue if (c isnot opt)

          retval = true
          var type = this.types[j]
          var as = this.as[j]
          var flags = this.flags[j]

          if (type is IntegerType and flags & ARG_VALUE_APPEND) {
            this.results.$(as) += 1
            # or more verbose
            # Map.set (this.results, as, this.results: get (as) + 1);
            break
          }

          if (type is BooleanType) {
            this.results.$(as) = true
          } else {
            if (flags & (ARG_VALUE_REQUIRED|ARG_VALUE_OPTIONAL)) {
              if (this.curidx is this.input_argc - 1 or
                  this.input_argv[this.curidx + 1][0] is '-') {
                if (flags & ARG_VALUE_REQUIRED) {
                  if this.verbose is true then
                    println (stderr, "error ${%s, arg) argument awaits a value")
                  orelse
                    this.err_message = format ("error ${%s, arg) argument awaits a value")

                  return notok
                }

                if (type is IntegerType or type is BooleanType) {
                  this.results.$(as) = true
                } else if (type is StringType) {
                  this.results.$(as) = ""
                }
                break
              }
            }

            this.curidx += 1
            if (type is IntegerType) {
              this.results.$(as) = this.input_argv[this.curidx]: to_integer ()
            } else if (type is StringType) {
              this.results.$(as) = this.input_argv[this.curidx]
            }
          }

          break
        }
      }

      if (retval is false) {
        if (this.exit_on_unknown) {
          if (this.verbose) {
            println ("-${%s, c: string_character ()}: unknown argument")
            this.print_description ()
          }

          return notok
        }
      }
    }

    return retval
  }

  "parse_long_arg" : func (arg) {
    if (arg is "--help") {
      if (this.print_and_exit_on_help) {
        this.print_description ()
        this.exit = true
        return 1
      }
    }

    var found = false
    for |j, opt| in this.longopts {
      if (null isnot opt and opt: len ()) {
        var long = "--" + opt
        var long_len = long: len ()
        if (long: eq_n (arg, long_len)) {
          found = true
          var type = this.types[j]
          var as = this.as[j]
          var flags = this.flags[j]

          ifnot (flags) {
            if (type is IntegerType or type is BooleanType) {
              this.results.$(as) = true
            } else if (type is StringType) {
              this.results.$(as) = ""
            }

            return true
          }

          if (long[-1] isnot '=') {
            if (flags & ARG_VALUE_REQUIRED|ARG_VALUE_OPTIONAL) {
              if (this.curidx is this.input_argc - 1 or
                  this.input_argv[this.curidx + 1][0] is '-') {
                if (flags & ARG_VALUE_REQUIRED) {
                  if this.verbose is true then
                    println (stderr, "error ${%s, arg) argument awaits a value")
                  orelse
                    this.err_message = format ("error ${%s, arg) argument awaits a value")

                  return notok
                }

                if type is IntegerType or type is BooleanType {
                  this.results.$(as) = true
                } else if type is StringType {
                  this.results.$(as) = ""
                }

                return true
              } else {
                this.curidx += 1
                if (type is IntegerType) {
                  this.results.$(as) = this.input_argv[this.curidx]: to_integer ()
                } else if (type is BooleanType) {
                  var b = this.input_argv[this.curidx]: to_integer ()
                  if (b < 0 or b > 1) {
                    b = false
                  }

                  this.results.$(as) = b
                } else if (type is StringType) {
                  this.results.$(as) = this.input_argv[this.curidx]
                }

                return true
              }
            }

            return true
          }

          var optval = arg: byte_in_str ('=')
          var vallen = optval: len ()

          String.advance (optval, 1);
          if (vallen is optval: len ()) {
            if (flags & ARG_VALUE_REQUIRED) {
              if this.verbose is true then
                println (stderr, "error ${%s, arg) argument requires a value")
              orelse
                this.err_message = format ("error ${%s, arg) requires a value")

              return notok

            } else if (type is BooleanType or type is IntegerType) {
              this.results.$(as) = true
            } else if (type is StringType) {
              this.results.$(as) = ""
            }

            return true
          }

          if (type is BooleanType) {
            var val = optval: to_integer ();
            if val isnot false then val = true

            this.results.$(as) = val

          } else if (type is IntegerType) {
            this.results.$(as) = opts: to_integer ()
          } else if (type is StringType) {
            this.results.$(as) = optval
          }

          break
        }
      }
    }

    if (found is false) {
      this.argv[this.argc] = arg
      this.argc += 1
    }

    return found
  }

public

  "add" : func (as, short, long, descr, type, flags) {
    this.idx += 1
    this.shortopts[this.idx] = short
    this.longopts[this.idx]  = long
    this.as[this.idx]        = as
    this.types[this.idx]     = type
    this.flags[this.idx]     = flags
    this.descr[this.idx]     = descr

    this.results.$(as) =
      if type is IntegerType or type is BooleanType
        then false orelse null

    ifnot (null is long) {
      var llen = long: len ()
      if llen > this.maxlen then this.maxlen = llen
    }
  }

  "print_description" : func {
    var msg = format ("Usage: ${%s, this.message} \n\n")
    var arlen = this.shortopts: len ()

    for (var i = 0; i < arlen; i += 1) {
      var slen = 0
      var is_short = 0
      if (this.shortopts[i]) {
        msg += "  -" + this.shortopts[i]
        slen += 2
        is_short = 1
      }

      var is_long = 0
      var llen = 0
      if (null isnot this.longopts[i]) {
        llen = this.longopts[i]: len ()
        if (llen) {
          is_long = 1
          if (is_short) {
            msg += ",--"
            slen += 1
          } else {
            msg += "  --"
          }
          msg += this.longopts[i]
        }
      }

      continue ifnot (is_short + is_long)

      var first = this.maxlen + 5
      var num_spaces = first - (llen + slen)

      if llen then num_spaces -= 2

      loop (num_spaces) {
        msg += ' '
      }

      msg += "  " + this.descr[i] + "\n"
    }

    println (msg)
  }

  "process" : func (argv, start) {
    var argc = len (argv)
    this.argv = string[argc]
    this.argc = 0
    this.input_argc = argc
    this.input_argv = argv

    var retval = false

    for (this.curidx = 0; this.curidx < argc; this.curidx += 1) {
      continue if (this.curidx < start)

      var arg = argv[this.curidx]

      if (arg is "--") {
        for (var j = this.curidx + 1; j < argc; j += 1) {
          this.argv[this.argc] = this.input_argv[j]
          this.argc += 1
        }
        return ok
      }

      if (arg[0] isnot '-') {
        this.argv[this.argc] = arg
        this.argc += 1
        continue
      }


      retval = false
      if arg[1] isnot '-' {
        retval = this.parse_short_arg (arg)

        if retval is notok then return notok

        if this.exit is true then return ok

        continue
      }

      retval = this.parse_long_arg (arg)

      if retval is notok then return notok

      if (retval is false) {
        if (this.exit_on_unknown) {
          if (this.verbose) {
            println ("${%s, arg}: unknown argument")
            this.print_description ()
          }

          return notok
        }
      }

      if this.exit is true then return ok
    }

    return ok
  }
}
