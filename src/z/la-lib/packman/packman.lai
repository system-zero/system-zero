import ("os")
import ("io")
import ("sh")
import ("dir")
import ("sys")
import ("file")
import ("path")
import ("crypt")

import ("net")
#import ("archive")

const string[0] INSTALLED

const concat_with = path_concat
const which = sys_which
const platform = os_platform
const arch = os_arch
const pwname = getpwname
const grname = getgrname
const uid = getuid
const gid = getgid
const fetch = net_fetch
const exists = file_exists
const stat = file_stat
const is_executable = file_is_executable
const remove = file_remove
const chmod = file_chmod
const copy = file_copy
const is_writable = file_is_writable
const is_readable = file_is_readable
const symlink = file_symlink
const key_exists = map_key_exists
const getcwd = dir_current
const chdir = dir_change
const is_directory = dir_is_directory
const mkdir = dir_make
const open = io_open
const write = io_fd_write
const read = io_fd_read
const base64_encode = crypt_base64_encode_file

const LANG_EXT
const LANG_DEF_EXT = ".lai"

const PACKMAN                    = "packman"
const PACKMAN_NO_VERBOSE         = 0
const PACKMAN_VERBOSE            = 1

const PACKMAN_FORCE              = 1

const PACKMAN_SOURCE_ARCHIVE     = 0
const PACKMAN_SOURCE_REPO        = 1

const PACKMAN_LIBRARY_TYPE       = 1
const PACKMAN_EXECUTABLE_TYPE    = 2

const PACKMAN_BUILD_EXTRACT      = 1
const PACKMAN_BUILD_COPY         = 2
const PACKMAN_BUILD_PATCH        = 3
const PACKMAN_BUILD_CONFIGURE    = 4
const PACKMAN_BUILD_MAKE         = 5
const PACKMAN_BUILD_MAKE_INSTALL = 6
const PACKMAN_BUILD_MD_CHECK     = 7
const PACKMAN_BUILD_USER_COM     = 8
const PACKMAN_BUILD_EVAL         = 9
const PACKMAN_BUILD_USER_COM_IF  = 10
const PACKMAN_BUILD_MKDIR        = 11
const PACKMAN_INSTALL_SHARED_LIBRARY = 12
const PACKMAN_INSTALL_STATIC_LIBRARY = 13
const PACKMAN_INSTALL_EXECUTABLE = 14
const LAST_BUILD_TYPE = PACKMAN_INSTALL_EXECUTABLE

const MD5TYPE                    = 1
const SHA256TYPE                 = 2
const SHA512TYPE                 = 3

const COLOR_ERR = "\e[31m"
const COLOR_PKG = "\e[32m"
const COLOR_DEP = "\e[33m"
const RESET = "\e[m"

func packman_error (msg) {
  if msg isnot null
    println (stderr, "${COLOR_ERR}${msg}")

  if errno
     println (stderr, errno_string (errno))

  println ("${RESET}")

  return notok
}

Type PackmanBuild {
  public
  msg,
  type,
  command

  private
  init : func (msg, type, com) {
    this.msg = msg
    this.type = type
    this.command = com
  }
}

Type PackmanSpec {
  private
  md
  name
  type
  home
  repo
  descr
  mlist
  bugtr
  build
  force
  force_rec
  cached
  soname
  db_dir
  lib_dir
  md_type
  license
  baseurl
  version
  archive
  sources
  depends
  recorded
  specfile
  extension
  build_dir
  webarchive
  cached_file
  installed_as
  build_dirname
  soname_version
  compiled_sources

  init : func (name) this.name = name

  read_cached_file : func () {
    if this.cached is null {
      var fd = open (this.cached_file, O_RDONLY, 0)
      return true if fd is null
      var s = read (fd)
      if s is null then
        return packman_error ("can not read " + this.cached_file)

      var r = eval (s)
      if r isnot ok
        return packman_error (this.cached_file + " evaluation error")
    }

    return false
  }

  public
  write_record : func {
    return ok if null is this.recorded

    var fd = open (this.cached_file, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR)
    return notok if fd is null

    return notok if notok is write (fd, "this.cached = {\n")

    return notok if notok is write (fd, "  version  : \"" + this.version + "\"\n")
    return notok if notok is write (fd, "  installed_as : \"" + this.installed_as + "\"\n")
    return notok if notok is write (fd, "  specfile : \"" + this.specfile + "\"\n")
    if this.recorded: key_exists ("compiled_sources") {
      return notok if notok is write (fd, "  compiled_sources : {\n")
      for k, v in this.recorded.compiled_sources {
        return notok if notok is write (fd, "    \"" + k + "\" : {\n      mtime : ")
        return notok if notok is write (fd, format ("${v.mtime}"))
        return notok if notok is write (fd, "\n      base : \"" + v.base + "\"\n")
        return notok if notok is write (fd, "    }\n")
      }

      return notok if notok is write (fd, "  }\n")
    }

    return write (fd, "}\n")
  }

  record : func {
    if this.recorded is null {
      this.recorded = {
        compiled_sources : {}
      }
    }

    var scwd = getcwd ()
    chdir (this.build_dir)

    ifnot null is this.compiled_sources {
      for v in this.compiled_sources {
        continue if this.recorded.compiled_sources: key_exists (v)
        continue ifnot v: exists ()

        var st = v: stat ()
        var base = base64_encode (v)
        this.recorded.compiled_sources.$(v) = { mtime : st.st_mtime, base : base }
      }
    }

    chdir (scwd)

    var v = this.specfile
    var st = v: stat ()
    var base = base64_encode (v)
    this.recorded.spec = { mtime : st.st_mtime, base : base }
  }

  should_build : func {
    return true if this.force is true
    return true ifnot this.cached_file: exists ()
    return true if this.installed_as is null

    if this.type is PACKMAN_LIBRARY_TYPE then
      return true ifnot (this.lib_dir: concat_with (this.installed_as)): exists ()

    var r = this.read_cached_file ()
    return notok if r is notok

    return true if r is true
    return true if this.cached is null
    return true ifnot this.cached: key_exists ("version")
    return true if this.cached.version isnot this.version

    if this.recorded: key_exists ("compiled_sources") {
      if this.recorded.compiled_sources: len () {
        return true ifnot this.cached: key_exists ("compiled_sources")
        return true ifnot this.cached.compiled_sources: len ()
      }

      for k, v in this.recorded.compiled_sources {
        return true ifnot this.cached.compiled_sources: key_exists (k)
        return true if this.cached.compiled_sources.$(k).mtime isnot v.mtime
        return true if this.cached.compiled_sources.$(k).base  isnot v.base
      }
    }

    return false
  }

  set : {
    md            : func (md)    this.md = md
    home          : func (home)  this.home = home
    repo          : func (repo)  this.repo = repo
    type          : func (type)  this.type = type
    descr         : func (descr) this.descr = descr
    mlist         : func (mlist) this.mlist = mlist
    bugtr         : func (bugtr) this.bugtr = bugtr
    build         : func (build) this.build = build
    force         : func (force) this.force = force
    force_rec     : func (fr)    this.force_rec = fr
    db_dir        : func (dir)   this.db_dir = dir
    lib_dir       : func (dir)   this.lib_dir = dir
    md_type       : func (type)  this.md_type = type
    license       : func (lic)   this.license = lic
    baseurl       : func (url)   this.baseurl = url
    version       : func (vers)  this.version = vers
    archive       : func (arch)  this.archive = arch
    sources       : func (src)   this.sources = src
    specfile      : func (f)     this.specfile = f
    extension     : func (ext)   this.extension = ext
    build_dir     : func (dir)   this.build_dir = dir
    webarchive    : func (arch)  this.webarchive = arch
    soname        : func (sn)    this.soname = sn
    soname_version: func (sv)    this.soname_version = sv
    depends       : func (d)     this.depends = d
    build_dirname : func (dir)   this.build_dirname = dir
    installed_as  : func (n)     this.installed_as = n
    cached_file   : func (f)     this.cached_file = f
    compiled_sources : func (s)  this.compiled_sources = s
  }

  get : {
    name          : func return this.name
    home          : func return this.home
    repo          : func return this.repo
    type          : func return this.type
    descr         : func return this.descr
    mlist         : func return this.mlist
    bugtr         : func return this.bugtr
    force         : func return this.force
    force_rec     : func return this.force_rec
    db_dir        : func return this.db_dir
    md            : func return this.md
    md_type       : func return this.md_type
    lib_dir       : func return this.lib_dir
    build         : func return this.build
    soname        : func return this.soname
    license       : func return this.license
    baseurl       : func return this.baseurl
    version       : func return this.version
    archive       : func return this.archive
    webarchive    : func return this.webarchive
    sources       : func return this.sources
    depends       : func return this.depends
    specfile      : func return this.specfile
    extension     : func return this.extension
    build_dir     : func return this.build_dir
    installed_as  : func return this.installed_as
    build_dirname : func return this.build_dirname
    soname_version: func return this.soname_version
    cached_file   : func return this.cached_file
    compiled_sources : func return this.compiled_sources
  }

  info : func (packman) {
    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)

    var msg =
      "SPEC NAME        : " + this.name + "\n" +
      "PACKAGE TYPE     : " + this.type:
        if x is PACKMAN_LIBRARY_TYPE then "Library" orelse "Executable" end + "\n" +
      "DESCRIPTION      : " + this.descr + "\n" +
      "VERSION          : " + this.version + "\n" +
      "LICENSE          : " + this.license:
        if x isnot null then x orelse "" end + "\n" +
      "HOME URL         : " + this.home:
        if x isnot null then x orelse "" end + "\n" +
      "ARCHIVE          :" + this.archive:
        if x is null then "\n"
        orelse " " + x +
          if (packman.get.src_dir () + "/" + this.archive): exists ()
              then " exists in the filesystem\n"
            orelse " doesn't exists in the filesystem\n" end +
      "REPOSITORY       : " + this.repo:
        if x isnot null then " " + x orelse "" end + "\n" +
      "SOURCES          :" + this.sources:
        if x isnot null then " " + packman.get.src_dir (): concat_with (x) orelse "" end + "\n" +
      "INSTALLED AS     : " + this.installed_as:
        if x isnot null then x orelse "unknown" end + "\n" +
      "MESSAGE DIGEST   : " + this.md:
        if x is null then "NONE" orelse x end + "\n" +
      "SPEC             : " + this.specfile + "\n" +
      "CACHED BUILD     : " + this.cached_file + "\n" +
      "BUILD DIRECTORY  : " + (packman.get.build_dir (): concat_with (this.build_dirname))

    return msg ifnot verb

    println (fp, msg)
   }
}

Type Packman {
  private
  spec
  sh
  curdir
  user
  group
  make_exec
  patch_exec
  fetch_exec
  fetch_args
  tar_exec
  tar_args
  git_exec
  clone_args
  pull_args
  verbose
  db_dir
  spec_dir
  src_dir
  data_dir
  pkg_data_dir
  tmp_dir
  build_dir
  sys_dir
  bin_dir
  lib_dir
  home_dir
  path
  platform
  arch
  cached_name

  init : func () {
    this.sh          = New Shell ()
    this.user        = uid (): pwname ()
    this.group       = gid (): grname ()
    this.make_exec   = qualifier ("make",   "make": which ())
    this.patch_exec  = qualifier ("patch", "patch": which ())
    this.fetch_exec  = qualifier ("wget",   "wget": which ())
    this.git_exec    = qualifier ("git",     "git": which ())
    this.tar_exec    = qualifier ("tar",     "tar": which ())
    this.tar_args    = qualifier ("tar_args",   "xf")
    this.clone_args  = qualifier ("clone_args", "clone")
    this.pull_args   = qualifier ("pull_args",   "pull")
    this.platform    = qualifier ("platform", "PLATFORM": sys_get ())
    this.arch        = qualifier ("arch",         "ARCH": sys_get ())
    this.path        = qualifier ("path",         "PATH": sys_get ())
    this.sys_dir     = qualifier ("sys_dir",    "SYSDIR": sys_get ())
    this.data_dir    = qualifier ("data_dir",  "DATADIR": sys_get ())
    this.tmp_dir     = qualifier ("tmp_dir",    "TMPDIR": sys_get ())
    this.home_dir    = qualifier ("home_dir",     "HOME": sys_get ())
    this.db_dir      = qualifier ("db_dir",       this.data_dir: concat_with ("packman/db"))
    this.spec_dir    = qualifier ("spec_dir",     this.data_dir: concat_with ("packman/specs"))
    this.src_dir     = qualifier ("src_dir",      this.data_dir: concat_with ("packman/sources"))
    this.build_dir   = qualifier ("build_dir",     this.tmp_dir: concat_with ("packman"))
    this.bin_dir     = qualifier ("bin_dir",       this.sys_dir: concat_with ("bin"))
    this.lib_dir     = qualifier ("lib_dir",       this.sys_dir: concat_with ("lib"))
    this.pkg_data_dir= qualifier ("pkg_data_dir", this.data_dir: concat_with ("packman/data")) 
    this.verbose     = qualifier ("verbose", PACKMAN_VERBOSE)
    this.cached_name = qualifier ("cached_name", ".cached.build")

    this.curdir = getcwd ()

    if LANG_EXT is null then
      LANG_EXT = qualifier ("lang_ext", LANG_DEF_EXT)

    if this.fetch_exec is null {
      this.fetch_exec = "curl": which ()

      ifnot null is this.fetch_exec then
        this.fetch_args = "-L"
    }

    ifnot this.build_dir: exists () {
      var m = 0755
      mkdir (this.build_dir, m; err : 1)
    }
  }

  fetch : func {
    if this.spec.webarchive is null {
      println (stderr, "${COLOR_ERR}ERROR: webarchive property hasn't been set${RESET}")
      return notok
    }

    if this.spec.baseurl is null {
      println (stderr, "${COLOR_ERR}ERROR: baseurl property hasn't been set${RESET}")
      return notok
    }

    var webarch = this.spec.baseurl: concat_with (this.spec.webarchive)
    var archive = this.src_dir: concat_with (this.spec.archive)

    if ok is webarch: fetch (; as : archive, verbose : 1) return ok

    if this.fetch_exec is null {
      println (stderr, "${COLOR_ERR}ERROR: neither wget nor curl has been found${RESET}")
      return notok
    }

    var com = this.fetch_exec + " " + this.fetch_args + " " + " -O " + archive + " " + webarch

    return if ok is this.sh:exec (com) then ok orelse notok
  }

  extract : func {
    if null is this.spec.archive {
      println (stderr, "${COLOR_ERR}ERROR: archive property hasn't been set${RESET}")
      return notok
    }

    var archive = this.src_dir: concat_with (this.spec.archive)

    ifnot archive: exists () {
      var curdir = getcwd ()
      return notok if notok is chdir (this.src_dir)
      return notok if notok is this.fetch ()
      return notok if notok is chdir (curdir)
    }

    #var r = Archive.extract_file (archive)
    #  println (r)
    #return ok if ok is r

    if null is this.tar_exec {
      println (stderr, "${COLOR_ERR}ERROR: the tar executable couldn't been found${RESET}")
      return notok
    }

    var com = this.tar_exec + " " + this.tar_args + " " + archive
    var retval = this.sh:exec (com)
    return if retval is notok or retval > ok then notok orelse ok
  }

  md_check :  func {
    var verb = qualifier ("verbose", 0)
    var fp = qualifier ("out_stream", stdout) 

    if this.spec is null {
      println (stderr, "${COLOR_ERR}ERROR: spec hasn't been set${RESET}")
      return notok
    }

    if this.spec.archive is null {
      println (stderr, "${COLOR_ERR}ERROR: archive property hasn't been set${RESET}")
      return notok
    }

    return ok if this.spec.md is null

    var md_type = if this.spec.md_type is null then MD5TYPE
                  orelse this.spec.md_type

    var archive = this.src_dir: concat_with (this.spec.archive)

    var is_eq = func (x) {
      return x is
        if md_type is MD5TYPE then
          archive: crypt_md5sum_file ()
        orelse
          if md_type is SH256TYPE then
            archive: crypt_sha256sum_file ()
          orelse
            archive: crypt_sha512sum_file ()
    } (this.spec.md)

    if verb then
      if is_eq then
        println (fp, "MD_CHECK: [OK]")
      orelse
        println (fp, "MD_CHECK: [NOTOK]")

     return is_eq
  }

  fetch_sources : func {
    if this.spec.sources is null {
      println (stderr, "${COLOR_ERR}ERROR: sources property hasn't been set${RESET}")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "${COLOR_ERR}ERROR: repo property hasn't been set${RESET}")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "${COLOR_ERR}ERROR: git executable couldn't been found${RESET}")
      return notok
    }

    var curdir = getcwd ()

    return notok if chdir (this.src_dir) is notok

    var com = this.git_exec + " " + this.clone_args + " " + this.spec.repo
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return chdir (curdir)
  }

  copy_sources : func {
    if null is this.spec.sources {
      println (stderr, "${COLOR_ERR}ERROR: sources property hasn't been set${RESET}")
      return notok
    }

    ifnot this.src_dir: is_directory () {
      if this.src_dir: exists () {
        println (stderr, "${COLOR_ERR}ERROR: ${this.src_dir}: not a directory${RESET}")
        return notok
      }
    }

    return notok if this.src_dir: chdir () is notok

    ifnot this.spec.sources: is_directory () then
      return notok if this.fetch_sources () is notok

    return notok if notok is this.build_dir: chdir ()

    return notok if this.src_dir: concat_with (this.spec.sources): file_copy (
       "."; force : 1, recursive : 1, update : 1, verbose : 2) is notok
  }

  change_to_build_dirname : func {
    if this.spec.build_dirname is null {
      println (stderr, "${COLOR_ERR}ERROR: build_dirname property hasn't been set${RESET}")
      return notok
    }

    if this.spec.build_dirname: chdir () is notok {
      println (stderr, "${COLOR_ERR}ERROR: couldn't change directory to ${this.spec.build_dirname}${RESET}")
      return notok
    }

    return ok
  }

  public
  set : {
    spec        : func (spec)  this.spec = spec
    patch_exec  : func (patch) this.patch_exec = patch
    fetch_exec  : func (fetch) this.fetch_exec = fetch
    fetch_args  : func (args)  this.fetch_args = args
    git_exec    : func (git)   this.git_exec = git
    clone_args  : func (args)  this.clone_args = args
    pull_args   : func (args)  this.pull_args = args
    verbose     : func (what)  this.verbose = what
    db_dir      : func (dir)   this.db_dir = dir
    spec_dir    : func (dir)   this.spec_dir = dir
    pkg_data_dir: func (dir)   this.pkg_data_dir = dir
    build_dir   : func (dir)   this.build_dir = dir
    src_dir     : func (dir)   this.src_dir = dir
    bin_dir     : func (dir)   this.bin_dir = dir
    sys_dir     : func (dir)   this.sys_dir = dir
    lib_dir     : func (dir)   this.lib_dir = dir
  }

  get : {
    spec        : func return this.spec
    db_dir      : func return this.db_dir
    spec_dir    : func return this.spec_dir
    pkg_data_dir: func return this.pkg_data_dir
    build_dir   : func return this.build_dir
    src_dir     : func return this.src_dir
    bin_dir     : func return this.bin_dir
    sys_dir     : func return this.sys_dir
    lib_dir     : func return this.lib_dir
  }

  new : {
    spec : func (name) {
      var specfile = this.spec_dir: concat_with (name + LANG_EXT)
      ifnot specfile: exists () {
        println ("${COLOR_ERR}ERROR: ${name} spec couldn't been found${RESET}")
        return null
      }

      var spec = evalfile (specfile)

      this.spec = spec

      ifnot this.db_dir: is_directory () {
        println (stderr, "${COLOR_ERR}ERROR: {this.db_dir} isnot a directory{RESET}")
        return null
      }

      var db_dir = this.spec:get.db_dir ()
      if db_dir is null {
        this.spec:set.db_dir (this.db_dir: concat_with (name))
        db_dir = this.spec:get.db_dir ()
      }

      ifnot db_dir: exists () then
        return null if db_dir: mkdir (0755; err : 1) is notok

      ifnot db_dir: is_directory () {
        println (stderr, "${COLOR_ERR}ERROR: {db_dir} isnot a directory{RESET}")
        return null
      }

      ifnot db_dir: is_writable () {
        println (stderr, "${COLOR_ERR}ERROR: {db_dir} isnot writable{RESET}")
        return null
      }

      ifnot db_dir: is_readable () {
        println (stderr, "${COLOR_ERR}ERROR: {db_dir} isnot readable{RESET}")
        return null
      }

      if this.spec:get.build_dirname () is null then
        this.spec:set.build_dirname (name)

      this.spec:set.specfile (specfile)
      this.spec:set.build_dir (this.build_dir: concat_with (this.spec:get.build_dirname ()))
      this.spec:set.lib_dir (this.lib_dir)
      this.spec:set.force (qualifier ("force", false))
      this.spec:set.force_rec (qualifier ("force_rec", false))

      if this.spec:get.cached_file () is null then
        this.spec:set.cached_file ((db_dir: concat_with (this.cached_name)))

      if this.spec:get.type () is null then
        this.spec:set.type (PACKMAN_LIBRARY_TYPE)

      if this.spec:get.repo () isnot null then
        if this.spec:get.sources () is null then
          this.spec:set.sources (name)

      if this.spec:get.soname () isnot null {
        if this.spec:get.type () isnot PACKMAN_LIBRARY_TYPE {
          println (stderr, "${COLOR_ERR}ERROR: awaiting a library type${RESET}")
          return null
        }

        if this.spec:get.soname_version () is null then
          println (stderr,  "${COLOR_ERR}WARNING: soname_version is missing. It will be installed as unknown_version${RESET}")
      }

      if this.spec:get.installed_as () is null {
        if this.spec:get.type () is PACKMAN_LIBRARY_TYPE {
          if this.spec:get.soname () isnot null {
            this.spec:set.installed_as ("lib" + this.spec:get.soname () + ".so." +
               (this.spec:get.soname_version (): if x isnot null then x
                 orelse "unknown_version"))
          } else {
            println (stderr,  "${COLOR_ERR}ERROR: soname is missing${RESET}")
            return null
          }

        } else if this.spec:get.type () is PACKMAN_EXECUTABLE_TYPE {
          this.spec:set.installed_as (spec.name)

        } else {
          println (stderr, "${COLOR_ERR}ERROR: unknown type of package${RESET}")
          return null
        }
      }

      return this.spec
    }
  }

  list : {
    specs : func {
      var verb = qualifier ("verbose", 1)
      var fp = qualifier ("out_stream", stdout) 
      var ar = this.spec_dir: dir_list ()
      return null if null is ar
      for i, v in ar
        ar[i] = v: path_basename_sans_extname ()
      return ar ifnot verb
      for v in ar
        println (fp, v)
      return ar
    }
  }

  info : func {
    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)

    var msg =
      "PLATFORM         : " + this.platform  + "\n" +
      "ARCHITECTURE     : " + this.arch      + "\n" +
      "USER             : " + this.user      + "\n" +
      "GROUP            : " + this.group     + "\n" +
      "SYSTEM DIRECTORY : " + this.sys_dir   + "\n" +
      "BIN    DIRECTORY : " + this.bin_dir   + "\n" +
      "LIB    DIRECTORY : " + this.lib_dir   + "\n" +
      "DB     DIRECTORY : " + this.db_dir    + "\n" +
      "SPEC   DIRECTORY : " + this.spec_dir  + "\n" +
      "SRC    DIRECTORY : " + this.src_dir   + "\n" +
      "TMP    DIRECTORY : " + this.tmp_dir   + "\n" +
      "BUILD  DIRECTORY : " + this.build_dir + "\n"

    if verb then println (fp, msg)

    if this.spec isnot null then
      append "\n" + this.spec:info (this; qualifiers ()) in msg

    return msg ifnot verb
  }

  update_repo : func {
    if this.spec is null {
      println (stderr, "${COLOR_ERR}ERROR: spec hasn't been set${RESET}")
      return notok
    }

    if this.spec.sources is null {
      println (stderr, "${COLOR_ERR}ERROR: sources property hasn't been set${RESET}")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "${COLOR_ERR}ERROR: repo property hasn't been set${RESET}")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "${COLOR_ERR}ERROR: git executable couldn't been found${RESET}")
      return notok
    }

    var curdir = getcwd ()

    return notok if notok is chdir (
      this.src_dir: concat_with (this.spec.sources))

    var com = this.git_exec + " " + this.pull_args
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return chdir (curdir)

  }

  build : func {
    var retval = notok

    if this.spec is null {
      println (stderr, "${COLOR_ERR}ERROR: spec hasn't been set${RESET}")
      return notok
    }

    if this.spec.build is null {
      println (stderr, "${COLOR_ERR}ERROR: build spec property hasn't been set${RESET}")
      return notok
    }

    if this.build_dir is null {
      println (stderr, "${COLOR_ERR}ERROR: build_dir property hasn't been set${RESET}")
      return notok
    }

    var depends = this.spec:get.depends ()
    ifnot null is depends {
      var p
      for v in depends {
        continue if INSTALLED: any (v)
        if this.verbose is true
          println ("Building [${COLOR_DEP}${v}${RESET}] a [${COLOR_PKG}${this.spec.name}${RESET}] dependency")

        var force_rec = this.spec:get.force_rec ()
        var q = {
          force : if this.spec:get.force () and force_rec then true orelse false
          force_rec : force_rec
        }

        p = New Packman ()

        var dep = p.new.spec (v; q)
        return notok if null is dep
        var deps = dep.get.depends ()
        ifnot null is deps {
          if deps: any (this.spec:get.name ()) {
            println (stderr, "${COLOR_ERR}circular dependency detected between ${this.spec:get.name ()} and ${v}${RESET}")
            return notok
          }
        }

        return notok if notok is p.build ()
      }
    }

    this.spec:record ()

    var r = this.spec:should_build ()
    return notok if notok is r
    if r is false {
      if this.verbose is true then
        println ("[${COLOR_PKG}${this.spec.name}${RESET}] is already installed")

      ifnot INSTALLED: any (this.spec.name)
        append this.spec.name in INSTALLED

      return ok
    }

    if this.build_dir: chdir () is notok {
      println (stderr, "${COLOR_ERR}ERROR: couldn't change directory to ${this.build_dir}${RESET}")
      return notok
    }

    if this.verbose is true {
      println ("Building [${COLOR_PKG}${this.spec.name}${RESET}]")
      if this.spec.descr isnot null then println (this.spec.descr)
      if this.spec.license isnot null then println ("License: ${this.spec.license}")
    }

    for 1 time {
      for action in this.spec.build {
        if this.verbose is true then
          ifnot null is action.msg then println (action.msg)

        if action.type is null or action.type < 0 or action.type > LAST_BUILD_TYPE {
          println (stderr, "${COLOR_ERR}ERROR: type build spec property, hasn't been set properly${RESET}")
          break 2
        }

        if action.type is PACKMAN_BUILD_EXTRACT {
          break 2 if notok is this.extract ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_COPY {
          break 2 if notok is this.copy_sources ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_MD_CHECK {
          var r = this.md_check (; verbose : 1)
          break 2 if notok is r
          ifnot r then break 2 ifnot null is this.spec.md
          continue
        }

        if action.type is PACKMAN_BUILD_CONFIGURE {
          var com = "./configure --prefix=" + this.sys_dir

          ifnot null is action.command then
            append format (" ${format (action.command)}") in com

          if this.sh:exec (com) isnot 0 {
            println (stderr, "${COLOR_ERR}ERROR: error while executing command: ${com}${RESET}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE {
          var com = this.make_exec;
          ifnot (null is action.command) then
            append format (" ${format (action.command)}") in com

          if this.sh:exec (com) isnot 0 {
            println (stderr, "${COLOR_ERR}ERROR: error while executing command: ${com}${RESET}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE_INSTALL {
          var com = this.make_exec + " install";
          ifnot (null is action.command) then
            append format (" ${format (action.command)}") in com

          if this.sh:exec (com) isnot ok {
            println (stderr, "${COLOR_ERR}ERROR: error while executing command: ${com}${RESET}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_INSTALL_SHARED_LIBRARY {
          var r = this.spec.installed_as: copy (this.lib_dir; verbose : 2, force : 1)
          break 2 if r is notok

          var f = this.lib_dir: concat_with (this.spec.installed_as)
          ifnot f: is_executable ()
            break 2 if notok is f: chmod (0755)

          f := path_basename_sans_extname ()
          var scwd = getcwd ()
          chdir (this.lib_dir)
          if f: exists () then remove (f)
          symlink (this.spec.installed_as, f; verbose : 2)
          chdir (scwd)
          continue
        }

        if action.type is PACKMAN_INSTALL_STATIC_LIBRARY {
          var l = ((this.spec.installed_as: path_basename_sans_extname ()): path_basename_sans_extname ()) + ".a"
          var r = l: copy (this.lib_dir; verbose : 2, force : 1)
          break 2 if r is notok
          continue
        }

        continue if action.command is null

        if action.type is PACKMAN_BUILD_EVAL {
          var com = action.command
          __retval = eval (com)
          break 2 ifnot ok is __retval
          continue
        }

        if action.type is PACKMAN_BUILD_USER_COM_IF {
          break 2 if action.command: typeof () isnot ArrayType and
                     action.command: typeof () isnot ListType
          break 2 if action.command: len () isnot 2
          var com =  action.command[0]
          var c   =  action.command[1]
          var r = true
          var cond =
            `r = if ` + format (format (c)) + ` then true orelse false end `
          __retval = eval (cond)
          break 2 ifnot ok is __retval
          continue if r is false
          action.command = com
          action.type = PACKMAN_BUILD_USER_COM
        }

        if action.type is PACKMAN_BUILD_USER_COM {
          var com = format ("${format (action.command)}")
          if this.sh:exec (com) isnot ok {
            println (stderr, "${COLOR_ERR}ERROR: error while executing command: ${com}${RESET}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MKDIR {
          var d
          var m = 0755
          var switch = false
          if action.command: typeof () is ListType {
            break 2 if action.command: len () isnot 2
            d = action.command[0]
            m = action.command[1]
            switch = action.command[2]
          } else if (action.command: typeof () is MapType {
            break 2 ifnot action.command: key_exists("dir")
            d = action.command.dir
            if action.command: key_exists ("mode") m = action.command.mode
            if action.command: key_exists ("switch") switch = action.command.switch
          } else if (action.command: typeof () is StringType {
            d = action.command
          } else {
            println (stderr, "${COLOR_ERR}ERROR: make directory unexpected datatype: ${action.command: typeAsString ()}${RESET}")
            break 2
          }

          ifnot d: exists () {
            var r = d: mkdir (m; err : 1)
            break 2 if r is notok
          }

          ifnot d: is_directory () {
            println (stderr, "${COLOR_ERR}ERROR: ${d}: not a directory${RESET}")
            break 2
          }

          if switch {
            var r = chdir (d)
            break 2 if r is notok
          }

          continue
        }

        if action.type is PACKMAN_INSTALL_EXECUTABLE {
          var r = action.command: copy (this.bin_dir; verbose : 2, force : 1)
          break 2 if r is notok
          var f = this.bin_dir: concat_with (action.command)
          ifnot f: is_executable ()
            break 2 if notok is f: chmod (0755)

          continue
        }
      }

      retval = this.spec: write_record ()
      append this.spec.name in INSTALLED
    }

    chdir (this.curdir)
    return retval
  }
}

func packman_make
  return New PackmanBuild ("[make]", PACKMAN_BUILD_MAKE, null)
func packman_make_with (x)
  return New PackmanBuild ("[make]", PACKMAN_BUILD_MAKE, x)
func packman_extract
  return New PackmanBuild ("[extracting]", PACKMAN_BUILD_EXTRACT, null)
func packman_install
  return New PackmanBuild ("[install]", PACKMAN_BUILD_MAKE_INSTALL, null)
func packman_install_with (x)
  return New PackmanBuild ("[install]", PACKMAN_BUILD_MAKE_INSTALL, x)
func packman_configure ()
  return New PackmanBuild ("[configure]", PACKMAN_BUILD_CONFIGURE, null)
func packman_configure_with (x)
  return New PackmanBuild ("[configure]", PACKMAN_BUILD_CONFIGURE, x)
func packman_command (m, com)
  return New PackmanBuild (if m is null then "[command]" orelse m end, PACKMAN_BUILD_USER_COM, com)
func packman_command_if (m, com, cond)
  return New PackmanBuild (if m is null then "[conditional command]" orelse m end, PACKMAN_BUILD_USER_COM_IF, [com, cond])
func packman_copy_sources
  return New PackmanBuild ("[copying sources]", PACKMAN_BUILD_COPY, null)
func packman_eval (m, s)
  return New PackmanBuild (if m is null then "[expression]" orelse m end, PACKMAN_BUILD_EVAL, s)
func packman_eval_if (m, s, x)
  return New PackmanBuild (if m is null then "[conditional expression]" orelse m end, PACKMAN_BUILD_EVAL, [s, x])
func packman_mkdir (d)
  return New PackmanBuild ("[making directory]", PACKMAN_BUILD_MKDIR, d)
func packman_install_shared_library ()
  return New PackmanBuild ("[installing shared library]", PACKMAN_INSTALL_SHARED_LIBRARY, null)
func packman_install_static_library ()
  return New PackmanBuild ("[installing static library]", PACKMAN_INSTALL_STATIC_LIBRARY, null)
func packman_install_executable (x)
  return New PackmanBuild ("[installing executable]", PACKMAN_INSTALL_EXECUTABLE, x)


public const Packman = {
  make               : packman_make
  make_with          : packman_make_with
  eval               : packman_eval
  eval_if            : packman_eval_if
  extract            : packman_extract
  install            : packman_install
  install_with       : packman_install_with
  configure          : packman_configure
  configure_with     : packman_configure_with
  copy_sources       : packman_copy_sources
  command            : packman_command
  command_if         : packman_command_if
  mkdir              : packman_mkdir
  install_executable : packman_install_executable
  install_shared_library : packman_install_shared_library
  install_static_library : packman_install_static_library
  new                : {
    spec : func (s) {
      var haskey = key_exists
      var to_string = integer_to_string

      ifnot s: haskey ("name") {
        println (stderr, "${COLOR_ERR}ERROR: name field is required${RESET}")
        return null
      }

      var specnew = New PackmanSpec (s.name)

      if s: haskey ("md")            then specnew.set.md (s.md)
      if s: haskey ("type")          then specnew.set.type (s.type)
      if s: haskey ("home")          then specnew.set.home (s.home)
      if s: haskey ("repo")          then specnew.set.repo (s.repo)
      if s: haskey ("descr")         then specnew.set.descr (s.descr)
      if s: haskey ("mlist")         then specnew.set.mlist (s.mlist)
      if s: haskey ("bugtr")         then specnew.set.bugtr (s.bugtr)
      if s: haskey ("md_type")       then specnew.set.md_type (s.md_type)
      if s: haskey ("build")         then specnew.set.build (s.build)
      if s: haskey ("sources")       then specnew.set.sources (s.sources)
      if s: haskey ("version")       then specnew.set.version (s.version)
      if s: haskey ("license")       then specnew.set.license (s.license)
      if s: haskey ("build_dirname") then specnew.set.build_dirname (s.build_dirname)
      if s: haskey ("baseurl")       then specnew.set.baseurl (s.baseurl)
      if s: haskey ("extension")     then specnew.set.extension (s.extension)
      if s: haskey ("archive")       then specnew.set.archive (s.archive)
      if s: haskey ("webarchive")    then specnew.set.webarchive (s.webarchive)
      if s: haskey ("soname")        then specnew.set.soname (s.soname)
      if s: haskey ("soname_version")then specnew.set.soname_version (s.soname_version)
      if s: haskey ("installed_as")  then specnew.set.installed_as (s.installed_as)
      if s: haskey ("depends")       then specnew.set.depends (s.depends)
      if s: haskey ("compiled_sources") then specnew.set.compiled_sources (s.compiled_sources)

      if s: haskey ("build") {
        if s.build: len () {
          if typeof (s.build) is MapType {
            if s.build: haskey ("1") {
              var map[0] build

              var i = 1
              var k = i: to_string (10)
              repeat {
                append s.build.$(k) in build
                i++
                k = i: to_string (10)
              } until s.build: haskey (k)

              specnew.set.build (build)

            } else {
              println (stderr, "${COLOR_ERR}ERROR: awaiting an inline map, with 1 as a key${RESET}")
              return null
            }

          } else if typeof (s.build) is ListType {
            var map[0] build
            for v in s.build
              append v in build

            specnew.set.build (build)
          } else if typeof (s.build) isnot ArrayType {
            println (stderr, "${COLOR_ERR}ERROR: awaiting an ArrayType with build instructions${RESET}");
            return null
          } else {
            specnew.set.build (s.build)
          }
        }
      }

      return specnew
    }
  }
}
