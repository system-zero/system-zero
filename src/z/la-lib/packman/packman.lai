import ("os")
import ("sh")
import ("dir")
import ("sys")
import ("file")
import ("path")
import ("crypt")

import ("net")

const PACKMAN                    = "Packman"

const PACKMAN_NO_VERBOSE         = 0
const PACKMAN_VERBOSE            = 1

const PACKMAN_SOURCE_ARCHIVE     = 0
const PACKMAN_SOURCE_REPO        = 1

const PACKMAN_BUILD_EXTRACT      = 1
const PACKMAN_BUILD_COPY         = 2
const PACKMAN_BUILD_PATCH        = 3
const PACKMAN_BUILD_CONFIGURE    = 4
const PACKMAN_BUILD_MAKE         = 5
const PACKMAN_BUILD_MAKE_INSTALL = 6
const PACKMAN_BUILD_MD_CHECK     = 7
const PACKMAN_BUILD_USER_COM     = 8
const PACKMAN_BUILD_EVAL         = 9
const PACKMAN_BUILD_USER_COM_IF  = 10
const PACKMAN_BUILD_MKDIR        = 11
var LAST_BUILD_TYPE              = PACKMAN_BUILD_MKDIR

const PACKMAN_DATADIR            = Sys.get ("DATADIR"): path_concat (PACKMAN)
const PACKMAN_SYSDIR             = Sys.get ("SYSDIR")
const PACKMAN_TMPDIR             = Sys.get ("TMPDIR")

const MD5TYPE                    = 1
const SHA256TYPE                 = 2
const SHA512TYPE                 = 3

Type PackmanBuild {
  public
  msg, type, command
  private
  init : func (msg, type, com) {
    this.msg = msg
    this.type = type
    this.command = com
  }
}

Type PackmanSpec {
  private
  name
  home
  type
  repo
  build
  descr
  md
  md_type
  license
  baseurl
  version
  archive
  webarchive
  build_dirname
  extension

  init : func (name) this.name = name

  public
  set : {
    md            : func (md)    this.md = md
    home          : func (home)  this.home = home
    repo          : func (repo)  this.repo = repo
    type          : func (type)  this.type = type
    descr         : func (descr) this.descr = descr
    md_type       : func (type)  this.md_type = type
    build         : func (build) this.build = build
    license       : func (lic)   this.license = lic
    baseurl       : func (url)   this.baseurl = url
    version       : func (vers)  this.version = vers
    archive       : func (arch)  this.archive = arch
    webarchive    : func (arch)  this.webarchive = arch
    sources       : func (src)   this.sources = src
    extension     : func (ext)   this.extension = ext
    build_dirname : func (dir)  this.build_dirname = dir
  }

  get : {
    name          : func return this.name
    home          : func return this.home
    repo          : func return this.repo
    type          : func return this.type
    descr         : func return this.descr
    md            : func return this.md
    md_type       : func return this.md_type
    build         : func return this.build
    license       : func return this.license
    baseurl       : func return this.baseurl
    version       : func return this.version
    archive       : func return this.archive
    webarchive    : func return this.webarchive
    sources       : func return this.sources
    extension     : func return this.extension
    build_dirname : func return this.build_dirname
  }

  info : func (packman) {
    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)
    var msg =
      "SPEC NAME        : " + this.name + "\n" +
      "DESCRIPTION      : " + this.descr + "\n" +
      "VERSION          : " + this.version + "\n" +
      "LICENSE          : " + this.license:
        if x isnot null then x orelse "" end + "\n" +
      "HOME URL         : " + this.home:
        if x isnot null then x orelse "" end + "\n" +
      "REPOSITORY       : " + this.repo:
        if x isnot null then x orelse "" end + "\n" +
      "ARCHIVE          : " + this.archive:
        if x is null then ""
        orelse x +
          if (packman.get.sources_dir () + "/" + this.archive): file_exists ()
              then " exists in the filesystem"
            orelse " doesn't exists in the filesystem" end +
      "\n" + "MESSAGE DIGEST   : " + this.md:
        if x is null then "NONE" orelse x end

    return msg ifnot verb
    println (fp, msg)
   }
}

Type Packman {
  private
  spec
  sh
  curdir
  user        : Os.getpwname (Os.getuid ())
  group       : Os.getgrname (Os.getgid ())
  make_exec   : Sys.which ("make")
  patch_exec  : Sys.which ("patch")
  fetch_exec  : Sys.which ("wget")
  fetch_args
  tar_exec    : Sys.which ("tar")
  tar_args    : "xf"
  git_exec    : Sys.which ("git")
  clone_args  : "clone"
  pull_args   : "pull"
  verbose     : PACKMAN_VERBOSE
  datadir     : PACKMAN_DATADIR
  spec_dir    : PACKMAN_DATADIR: path_concat ("specs")
  sources_dir : PACKMAN_DATADIR: path_concat ("sources")
  pkg_data_dir: PACKMAN_DATADIR: path_concat ("data")
  tmpdir      : PACKMAN_TMPDIR
  builddir    : PACKMAN_TMPDIR:  path_concat (PACKMAN)
  sysdir      : PACKMAN_SYSDIR
  bindir      : PACKMAN_SYSDIR:  path_concat ("bin")
  libdir      : PACKMAN_SYSDIR:  path_concat ("lib")
  homedir     : Sys.get ("HOME")
  path        : Sys.get ("PATH")
  platform    : Os.platform ()
  arch        : Os.arch ()

  init : func {
    this.sh = New Shell ()
    this.user = Os.getpwname (Os.getuid ())
    this.group = Os.getgrname (Os.getgid ())
    this.make_exec = Sys.which ("make")
    this.patch_exec = Sys.which ("patch")
    this.fetch_exec = Sys.which ("wget")
    this.tar_exec = Sys.which ("tar")
    this.tar_args = "xf"
    this.git_exec = Sys.which ("git")
    this.clone_args = "clone"
    this.pull_args = "pull"
    this.verbose = PACKMAN_VERBOSE

    var sysdir = Sys.get ("SYSDIR")
    var datadir = Sys.get ("DATADIR")
    var tmpdir = Sys.get ("TMPDIR")

    this.spec_dir = datadir: path_concat ("Packman/specs")
    this.sources_dir = datadir: path_concat ("Packman/sources")
    this.builddir = tmpdir: path_concat ("Packman")
    this.platform = Sys.get ("PLATFORM")
    this.homedir = Sys.get ("HOME")
    this.datadir = datadir
    this.tmpdir = tmpdir
    this.sysdir = sysdir
    this.bindir = sysdir: path_concat ("bin")
    this.libdir = sysdir: path_concat ("lib")
    this.path = Sys.get ("PATH")

    this.curdir = Dir.current ()
    if this.fetch_exec is null {
      this.fetch_exec = Sys.which ("curl")

      ifnot null is this.fetch_exec then
        this.fetch_args = "-L"
    }
  }

  fetch : func {
    if this.spec.webarchive is null {
      println (stderr, "webarchive property hasn't been set")
      return notok
    }

    if this.spec.baseurl is null {
      println (stderr, "baseurl property hasn't been set")
      return notok
    }

    var webarch = this.spec.baseurl: path_concat (this.spec.webarchive)
    var archive = this.sources_dir: path_concat (this.spec.archive)

    if ok is Net.fetch (webarch; as : archive, verbose : 1) return ok

    if this.fetch_exec is null {
      println (stderr, "neither wget nor curl has been found")
      return notok
    }

    var com = this.fetch_exec + " " + this.fetch_args + " " + " -O " + archive + " " + webarch

    return if ok is this.sh:exec (com) then ok orelse notok
  }

  extract : func {
    if null is this.tar_exec {
      println (stderr, "the tar executable couln't been found")
      return notok
    }

    if null is this.spec.archive {
      println (stderr, "archive property hasn't been set")
      return notok
    }

    var archive = this.sources_dir: path_concat (this.spec.archive)

    ifnot archive: file_exists () {
      var curdir = Dir.current ()
      return notok if notok is Dir.change (this.sources_dir)
      return notok if notok is this.fetch ()
      return notok if notok is Dir.change (curdir)
    }

    var com = this.tar_exec + " " + this.tar_args + " " + archive
    var retval = this.sh:exec (com)
    return if retval is notok or retval > ok then notok orelse ok
  }

  md_check :  func {
    var verb = qualifier ("verbose", 0)
    var fp = qualifier ("out_stream", stdout) 

    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.spec.archive is null {
      println (stderr, "archive property hasn't been set")
      return notok
    }

    return ok if this.spec.md is null

    var md_type = if this.spec.md_type is null then MD5TYPE
                  orelse this.spec.md_type

    var archive = this.sources_dir: path_concat (this.spec.archive)

    var is_eq = this.spec.md: lambda (x) {
      return x is
        if md_type is MD5TYPE then
          archive: crypt_md5sum_file ()
        orelse
          if md_type is SH256TYPE then
            archive: crypt_sha256sum_file ()
          orelse
            archive: crypt_sha512sum_file ()
    } ()

    if verb then
      if is_eq then
        println (fp, "MD_CHECK: [OK]")
      orelse
        println (fp, "MD_CHECK: [NOTOK]")

     return is_eq
  }

  fetch_sources : func {
    if this.spec.sources is null {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "repo property hasn't been set")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "git executable couldn't been found")
      return notok
    }

    var curdir = Dir.current ()

    return notok if Dir.change (this.sources_dir) is notok

    var com = this.git_exec + " " + this.clone_args + " " + this.spec.repo
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return Dir.change (curdir)
  }

  copy_sources : func {
    if null is this.spec.sources {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    ifnot this.sources_dir: dir_is_directory () {
      if this.sources_dir: file_exists () {
        println (stderr, "${this.sources_dir}: not a directory")
        return notok
      }
    }

    return notok if this.sources_dir: dir_change () is notok

    ifnot this.spec.sources: dir_is_directory () then
      return notok if this.fetch_sources () is notok

    return notok if notok is this.builddir: dir_change ()

    return notok if this.sources_dir: path_concat (this.spec.sources): file_copy (
       "."; force : 1, recursive : 1, update : 1, verbose : 2) is notok
  }

  change_to_build_dirname : func {
    if this.spec.build_dirname is null {
      println (stderr, "build_dirname property hasn't been set")
      return notok
    }

    if this.spec.build_dirname: dir_change () is notok {
      println (stderr, "couldn't change directory to ${this.spec.build_dirname}")
      return notok
    }

    return ok
  }

  public
  set : {
    spec        : func (spec)  this.spec = spec
    patch_exec  : func (patch) this.patch_exec = patch
    fetch_exec  : func (fetch) this.fetch_exec = fetch
    fetch_args  : func (args)  this.fetch_args = args
    git_exec    : func (git)   this.git_exec = git
    clone_args  : func (args)  this.clone_args = args
    pull_args   : func (args)  this.pull_args = args
    verbose     : func (what)  this.verbose = what
    spec_dir    : func (dir)   this.spec_dir = dir
    pkg_data_dir: func (dir)   this.pkg_data_dir = dir
    builddir    : func (dir)   this.builddir = dir
    sources_dir : func (dir)   this.sources_dir = dir
    bindir      : func (dir)   this.bindir = dir
    sysdir      : func (dir)   this.sysdir = dir
    libdir      : func (dir)   this.libdir = dir
  }

  get : {
    spec        : func return this.spec
    spec_dir    : func return this.spec_dir
    pkg_data_dir: func return this.pkg_data_dir
    builddir    : func return this.builddir
    sources_dir : func return this.sources_dir
    bindir      : func return this.bindir
    sysdir      : func return this.sysdir
    libdir      : func return this.libdir
  }

  new : {
    spec : func (name) {
      var specname = this.spec_dir: path_concat (name + ".lai")
      this.spec = evalfile (specname)
      return this.spec
    }
  }

  list : {
    specs : func {
      var verb = qualifier ("verbose", 1)
      var fp = qualifier ("out_stream", stdout) 
      var ar = this.spec_dir: dir_list ()
      return null if null is ar
      for i, v in ar
        ar[i] = v: path_basename_sans_extname ()
      return ar ifnot verb
      for v in ar
        println (fp, v)
      return ar
    }
  }

  info : func {
    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)

    var msg =
      "PLATFORM         : " + this.platform + "\n" +
      "ARCHITECTURE     : " + this.arch     + "\n" +
      "SYSTEM DIRECTORY : " + this.sysdir   + "\n" +
      "BIN    DIRECTORY : " + this.bindir   + "\n" +
      "LIB    DIRECTORY : " + this.libdir   + "\n" +
      "BUILD  DIRECTORY : " + this.builddir + "\n" +
      "USER             : " + this.user     + "\n" +
      "GROUP            : " + this.group    + "\n"

    if verb then println (fp, msg)

    if this.spec isnot null then
      append "\n" + this.spec:info (this; qualifiers ()) in msg

    return msg ifnot verb
  }

  update_repo : func {
    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.spec.sources is null {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "repo property hasn't been set")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "git executable couldn't been found")
      return notok
    }

    var curdir = Dir.current ()

    return notok if notok is Dir.change (
      this.sources_dir: path_concat (this.spec.sources)

    var com = this.git_exec + " " + this.pull_args
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return Dir.change (curdir)

  }

  build : func {
    var retval = notok

    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.spec.build is null {
      println (stderr, "build spec property hasn't been set")
      return notok
    }

    if this.builddir is null {
      println (stderr, "builddir property hasn't been set")
      return notok
    }

    if this.builddir: dir_change () is notok {
      println (stderr, "couldn't change directory to ${this.builddir}")
      return notok
    }

    if this.verbose is true {
      println ("Building " + this.spec.name)
      if this.spec.descr isnot null then println (this.spec.descr)
      if this.spec.license isnot null then println ("License: ${this.spec.license}")
    }

    for 1 time {
      for action in this.spec.build {
        if this.verbose is true then
          ifnot null is action.msg then println (action.msg)

        if action.type is null or action.type < 0 or action.type > LAST_BUILD_TYPE {
          println (stderr, "type build spec property, hasn't been set properly")
          break 2
        }

        if action.type is PACKMAN_BUILD_EXTRACT {
          break 2 if notok is this.extract ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_COPY {
          break 2 if notok is this.copy_sources ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_MD_CHECK {
          var r = this.md_check (; verbose : 1)
          break 2 if notok is r
          ifnot r then break 2 ifnot null is this.spec.md
          continue
        }

        if action.type is PACKMAN_BUILD_CONFIGURE {
          var com = "./configure --prefix=" + this.sysdir

          ifnot (null is action.command) then
            append format (" ${format (action.command)}") in com

          if (this.sh:exec (com) isnot 0) {
            println (stderr, "error while executing command: ${com}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE {
          var com = this.make_exec;
          ifnot (null is action.command) then
            append format (" ${format (action.command)}") in com

          if this.sh:exec (com) isnot 0 {
            println (stderr, "error while executing command: ${com}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE_INSTALL {
          var com = this.make_exec + " install";
          ifnot (null is action.command) then
            append format (" ${format (action.command)}") in com

          if this.sh:exec (com) isnot ok {
            println (stderr, "error while executing command: ${com}")
            break 2
          }

          continue
        }

        continue if action.command is null

        if action.type is PACKMAN_BUILD_EVAL {
          var com = action.command
          __retval = eval (com)
          break 2 ifnot ok is __retval
          continue
        }

        if action.type is PACKMAN_BUILD_USER_COM_IF {
          break 2 if action.command: typeof () isnot ArrayType and
                     action.command: typeof () isnot ListType
          break 2 if action.command: len () isnot 2
          var com =  action.command[0]
          var c   =  action.command[1]
          var r = true
          var cond =
            `r = if ` + format (format (c)) + ` then true orelse false end `
          __retval = eval (cond)
          break 2 ifnot ok is __retval
          continue if r is false
          action.command = com
          action.type = PACKMAN_BUILD_USER_COM
        }

        if action.type is PACKMAN_BUILD_USER_COM {
          var com = format ("${format (action.command)}")
          if this.sh:exec (com) isnot ok {
            println (stderr, "error while executing command: ${com}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MKDIR {
          var d
          var m = 0755
          var switch = false
          if action.command: typeof () is ListType {
            break 2 if action.command: len () isnot 2
            d = action.command[0]
            m = action.command[1]
            switch = action.command[2]
          } else if (action.command: typeof () is MapType {
            break 2 ifnot action.command: key_exists("dir")
            d = action.command.dir
            if action.command: key_exists ("mode") m = action.command.mode
            if action.command: key_exists ("switch") switch = action.command.switch
          } else if (action.command: typeof () is StringType {
            d = action.command
          } else {
            println (stderr, "packman mkdir unexpected datatype: ${action.command: typeAsString ()}")
            break 2
          }

          ifnot d: file_exists () {
            var r = d: dir_make (d, m; err : 1)
            break 2 if r is notok
          }

          ifnot d: dir_is_directory () {
            println (stderr, "${d}: not a directory")
            break 2
          }

          if switch {
            var r = Dir.change (d)
            break 2 if r is notok
          }

          continue
        }
      }

      retval = ok
    }

    Dir.change (this.curdir)
    return retval
  }
}

func packman_make
  return New PackmanBuild ("[make]", PACKMAN_BUILD_MAKE, null)
func packman_make_with (x)
  return New PackmanBuild ("[make]", PACKMAN_BUILD_MAKE, x)
func packman_extract
  return New PackmanBuild ("[extracting]", PACKMAN_BUILD_EXTRACT, null)
func packman_install
  return New PackmanBuild ("[install]", PACKMAN_BUILD_MAKE_INSTALL, null)
func packman_install_with (x)
  return New PackmanBuild ("[install]", PACKMAN_BUILD_MAKE_INSTALL, x)
func packman_configure ()
  return New PackmanBuild ("[configure]", PACKMAN_BUILD_CONFIGURE, null)
func packman_configure_with (x)
  return New PackmanBuild ("[configure]", PACKMAN_BUILD_CONFIGURE, x)
func packman_command (m, com)
  return New PackmanBuild (if m is null then "[command]" orelse m end, PACKMAN_BUILD_USER_COM, com)
func packman_command_if (m, com, cond)
  return New PackmanBuild (if m is null then "[conditional command]" orelse m end, PACKMAN_BUILD_USER_COM_IF, [com, cond])
func packman_copy_sources
  return New PackmanBuild ("[copying sources]", PACKMAN_BUILD_COPY, null)
func packman_eval (m, s)
  return New PackmanBuild (if m is null then "[expression]" orelse m end, PACKMAN_BUILD_EVAL, s)
func packman_eval_if (m, s, x)
  return New PackmanBuild (if m is null then "[conditional expression]" orelse m end, PACKMAN_BUILD_EVAL, [s, x])
func packman_mkdir (d)
  return New PackmanBuild ("[making directory]", PACKMAN_BUILD_MKDIR, d)

public const Packman = {
  make           : packman_make
  make_with      : packman_make_with
  eval           : packman_eval
  eval_if        : packman_eval_if
  extract        : packman_extract
  install        : packman_install
  install_with   : packman_install_with
  configure      : packman_configure
  configure_with : packman_configure_with
  copy_sources   : packman_copy_sources
  command        : packman_command
  command_if     : packman_command_if
  mkdir          : packman_mkdir
  new            : {
    spec : func (s) {
      var haskey = map_key_exists
      var to_string = integer_to_string

      ifnot s: haskey ("name") {
        println (stderr, "name field is required")
        return null
      }

      var specnew = New PackmanSpec (s.name)

      if s: haskey ("md")            then specnew.set.md (s.md)
      if s: haskey ("home")          then specnew.set.home (s.home)
      if s: haskey ("repo")          then specnew.set.repo (s.repo)
      if s: haskey ("descr")         then specnew.set.descr (s.descr)
      if s: haskey ("md_type")       then specnew.set.md_type (s.md_type)
      if s: haskey ("build")         then specnew.set.build (s.build)
      if s: haskey ("sources")       then specnew.set.sources (s.sources)
      if s: haskey ("version")       then specnew.set.version (s.version)
      if s: haskey ("license")       then specnew.set.license (s.license)
      if s: haskey ("build_dirname") then specnew.set.build_dirname (s.build_dirname)
      if s: haskey ("baseurl")       then specnew.set.baseurl (s.baseurl)
      if s: haskey ("extension")     then specnew.set.extension (s.extension)
      if s: haskey ("archive")       then specnew.set.archive (s.archive)
      if s: haskey ("webarchive")    then specnew.set.webarchive (s.webarchive)

      if s: haskey ("build") {
        if s.build: len () {
          if typeof (s.build) is MapType {
            if s.build: haskey ("1") {
              var map[0] build

              var i = 1
              var k = i: to_string (10)
              do {
                append s.build.$(k) in build
                i++
                k = i: to_string (10)
              } while s.build: haskey (k)

              specnew.set.build (build)

            } else {
              println ("awaiting an inline map, with 1 as a key")
              return null
            }

          } else if typeof (s.build) is ListType {
            var map[0] build
            for v in s.build
              append v in build

            specnew.set.build (build)
          } else if typeof (s.build) isnot ArrayType {
            println (stderr, "awaiting an ArrayType with build instructions");
            return null
          } else {
            specnew.set.build (s.build)
          }
        }
      }

      return specnew
    }
  }
}
