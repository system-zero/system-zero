import ("os")
import ("sh")
import ("dir")
import ("sys")
import ("file")
import ("path")
import ("crypt")

if #isdefined "BOOTSTRAP"
  import ("net")

const PACKMAN                    = "Packman"

const PACKMAN_NO_VERBOSE         = 0
const PACKMAN_VERBOSE            = 1

const PACKMAN_SOURCE_ARCHIVE     = 0
const PACKMAN_SOURCE_REPO        = 1

const PACKMAN_BUILD_EXTRACT      = 0
const PACKMAN_BUILD_COPY         = 1
const PACKMAN_BUILD_PATCH        = 2
const PACKMAN_BUILD_CONFIGURE    = 3
const PACKMAN_BUILD_MAKE         = 4
const PACKMAN_BUILD_MAKE_INSTALL = 5
const PACKMAN_BUILD_MD_CHECK     = 6
const PACKMAN_BUILD_USER_COM     = 7
const PACKMAN_BUILD_EVAL         = 8
var LAST_BUILD_TYPE              = PACKMAN_BUILD_EVAL

const PACKMAN_DATADIR            = Sys.get ("DATADIR"): path_concat (PACKMAN)
const PACKMAN_SYSDIR             = Sys.get ("SYSDIR")
const PACKMAN_TMPDIR             = Sys.get ("TMPDIR")

const MD5TYPE                    = 1
const SHA256TYPE                 = 2
const SHA512TYPE                 = 3

Type PackmanBuild {
  msg, type, command
  init : func (msg, type, com) {
    this.msg = msg
    this.type = type
    this.command = com
  }
}

Type PackmanSpec {
  private
  name
  home
  type
  repo
  build
  descr
  md
  md_type
  license
  baseurl
  version
  archive
  build_dirname
  extension

  init : func (name) this.name = name

  public
  set : {
    home      : func (home)    this.home = home
    repo      : func (repo)    this.repo = repo
    type      : func (type)    this.type = type
    descr     : func (descr)   this.descr = descr
    md        : func (md)      this.md = md
    md_type   : func (type)    this.md_type = type
    build     : func (build)   this.build = build
    license   : func (lic)     this.license = lic
    baseurl   : func (url)     this.baseurl = url
    version   : func (vers)    this.version = vers
    archive   : func (arch)    this.archive = arch
    sources   : func (src)     this.sources = src
    extension : func (ext)     this.extension = ext
    build_dirname : func (dir) this.build_dirname = dir
  }

  get : {
    name      : func return this.name
    home      : func return this.home
    repo      : func return this.repo
    type      : func return this.type
    descr     : func return this.descr
    md        : func return this.md
    md_type   : func return this.md_type
    build     : func return this.build
    license   : func return this.license
    baseurl   : func return this.baseurl
    version   : func return this.version
    archive   : func return this.archive
    sources   : func return this.sources
    extension : func return this.extension
    build_dirname : func return this.build_dirname
  }

  info : func (packman) {
    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)
    var msg =
      "SPEC NAME        : " + this.name + "\n" +
      "DESCRIPTION      : " + this.descr + "\n" +
      "VERSION          : " + this.version + "\n" +
      "LICENSE          : " + this.license:
        if x isnot null then x orelse "" end + "\n" +
      "HOME URL         : " + this.home:
        if x isnot null then x orelse "" end + "\n" +
      "REPOSITORY       : " + this.repo:
        if x isnot null then x orelse "" end + "\n" +
      "ARCHIVE          : " + this.archive:
        if x is null then ""
        orelse x +
          if (packman.get.sources_dir () + "/" + this.archive): file_exists ()
              then " exists in the filesystem"
            orelse " doesn't exists in the filesystem" end +
      "\n" + "MESSAGE DIGEST   : " + this.md:
        if x is null then "NONE" orelse x end

    return msg ifnot verb
    println (fp, msg)
   }
}

Type Packman {
  private
  spec
  sh
  curdir
  user        : Os.getpwname (Os.getuid ())
  group       : Os.getgrname (Os.getgid ())
  make_exec   : Sys.which ("make")
  patch_exec  : Sys.which ("patch")
  fetch_exec  : Sys.which ("wget")
  fetch_args
  tar_exec    : Sys.which ("tar")
  tar_args    : "xf"
  git_exec    : Sys.which ("git")
  clone_args  : "clone"
  pull_args   : "pull"
  verbose     : PACKMAN_VERBOSE
  datadir     : PACKMAN_DATADIR
  spec_dir    : PACKMAN_DATADIR: path_concat ("specs")
  sources_dir : PACKMAN_DATADIR: path_concat ("sources")
  pkg_data_dir: PACKMAN_DATADIR: path_concat ("data")
  tmpdir      : PACKMAN_TMPDIR
  builddir    : PACKMAN_TMPDIR:  path_concat (PACKMAN)
  sysdir      : PACKMAN_SYSDIR
  bindir      : PACKMAN_SYSDIR:  path_concat ("bin")
  libdir      : PACKMAN_SYSDIR:  path_concat ("lib")
  homedir     : Sys.get ("HOME")
  path        : Sys.get ("PATH")
  platform    : Os.platform ()
  arch        : Os.arch ()

  init : func {
    this.sh = New Shell ()
    this.user = Os.getpwname (Os.getuid ())
    this.group = Os.getgrname (Os.getgid ())
    this.make_exec = Sys.which ("make")
    this.patch_exec = Sys.which ("patch")
    this.fetch_exec = Sys.which ("wget")
    this.tar_exec = Sys.which ("tar")
    this.tar_args = "xf"
    this.git_exec = Sys.which ("git")
    this.clone_args = "clone"
    this.pull_args = "pull"
    this.verbose = PACKMAN_VERBOSE

    var sysdir = Sys.get ("SYSDIR")
    var datadir = Sys.get ("DATADIR")
    var tmpdir = Sys.get ("TMPDIR")

    this.spec_dir = datadir: path_concat ("Packman/specs")
    this.sources_dir = datadir: path_concat ("Packman/sources")
    this.builddir = tmpdir: path_concat ("Packman")
    this.platform = Sys.get ("PLATFORM")
    this.homedir = Sys.get ("HOME")
    this.datadir = datadir
    this.tmpdir = tmpdir
    this.sysdir = sysdir
    this.bindir = sysdir: path_concat ("/bin")
    this.libdir = sysdir: path_concat ("/lib")
    this.path = Sys.get ("PATH")

    this.curdir = Dir.current ()
    if this.fetch_exec is null {
      this.fetch_exec = Sys.which ("curl")

      ifnot null is this.fetch_exec then
        this.fetch_args = "-L"
    }
  }

  fetch : func {
    if this.spec.archive is null {
      println (stderr, "archive property hasn't been set")
      return notok
    }

    if this.spec.baseurl is null {
      println (stderr, "baseurl property hasn't been set")
      return notok
    }

    var webarch = this.spec.baseurl: path_concat (this.spec.archive)
    var archive = this.sources_dir: path_concat (this.spec.archive)

    if #isdefined "BOOTSTRAP" then
      if ok is Net.fetch (webarch; as : archive) then
        return ok

    if this.fetch_exec is null {
      println (stderr, "neither wget nor curl has been found")
      return notok
    }

    var com = this.fetch_exec + " " + this.fetch_args + " " + " -O " + archive + " " + webarch

    return if ok is this.sh:exec (com) then ok orelse notok
  }

  extract : func {
    if null is this.tar_exec {
      println (stderr, "the tar executable couln't been found")
      return notok
    }

    if null is this.spec.archive {
      println (stderr, "archive property hasn't been set")
      return notok
    }

    var archive = this.sources_dir: path_concat (this.spec.archive)

    ifnot archive: file_exists () then
      return notok if notok is this.fetch ()

    var com = this.tar_exec + " " + this.tar_args + " " + archive
    var retval = this.sh:exec (com)
    return if retval is notok or retval > ok then notok orelse ok
  }

  md_check :  func {
    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.spec.archive is null {
      println (stderr, "archive property hasn't been set")
      return notok
    }

    return ok if this.spec.md is null

    var md_type = if this.spec.md_type is null then MD5TYPE
                  orelse this.spec.md_type

    var verb = qualifier ("verbose", 0)
    var fp = qualifier ("out_stream", stdout) 

    var archive = this.sources_dir: path_concat (this.spec.archive)

    var is_eq = this.spec.md: lambda (x) {
      return x is
        if md_type is MD5TYPE then
          archive: crypt_md5sum_file ()
        orelse
          if md_type is SH256TYPE then
            archive: crypt_sha256sum_file ()
          orelse
            archive: crypt_sha512sum_file ()
    } ()

    if verb then
      if is_eq then
        println (fp, "MD_CHECK: [OK]")
      orelse
        println (fp, "MD_CHECK: [NOTOK]")

     return is_eq
  }

  fetch_sources : func {
    if this.spec.sources is null {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "repo property hasn't been set")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "git executable couldn't been found")
      return notok
    }

    var curdir = Dir.current ()

    return notok if Dir.change (this.sources_dir) is notok

    var com = this.git_exec + " " + this.clone_args + " " + this.spec.repo
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return Dir.change (curdir)
  }

  copy_sources : func {
    if null is this.spec.sources {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    ifnot this.sources_dir: dir_is_directory () {
      if this.sources_dir: file_exists () {
        println (stderr, "${%s, this.sources_dir}: not a directory")
        return notok
      }
    }

    return notok if this.sources_dir: dir_change () is notok

    ifnot this.spec.sources: dir_is_directory () then
      return notok if this.fetch_sources () is notok

    return notok if notok is this.builddir: dir_change ()

    return notok if this.sources_dir: path_concat (this.spec.sources): file_copy (
       "."; force : 1, recursive : 1, update : 1, verbose : 2) is notok


  }

  change_to_build_dirname : func {
    if this.spec.build_dirname is null {
      println (stderr, "build_dirname property hasn't been set")
      return notok
    }

    if this.spec.build_dirname: dir_change () is notok {
      println (stderr, "couldn't change directory to ${%s, this.spec.build_dirname}")
      return notok
    }

    return ok
  }

  public
  set : {
    spec        : func (spec)  this.spec = spec
    patch_exec  : func (patch) this.patch_exec = patch
    fetch_exec  : func (fetch) this.fetch_exec = fetch
    fetch_args  : func (args)  this.fetch_args = args
    git_exec    : func (git)   this.git_exec = git
    clone_args  : func (args)  this.clone_args = args
    pull_args   : func (args)  this.pull_args = args
    verbose     : func (what)  this.verbose = what
    spec_dir    : func (dir)   this.spec_dir = dir
    pkg_data_dir: func (dir)   this.pkg_data_dir = dir
    builddir    : func (dir)   this.builddir = dir
    sources_dir : func (dir)   this.sources_dir = dir
    bindir      : func (dir)   this.bindir = dir
    sysdir      : func (dir)   this.sysdir = dir
    libdir      : func (dir)   this.libdir = dir
  }

  get : {
    spec        : func return this.spec
    spec_dir    : func return this.spec_dir
    pkg_data_dir: func return this.pkg_data_dir
    builddir    : func return this.builddir
    sources_dir : func return this.sources_dir
    bindir      : func return this.bindir
    sysdir      : func return this.sysdir
    libdir      : func return this.libdir
  }

  new : {
    spec : func (name) {
      var specname = this.spec_dir: path_concat (name + ".lai")
      this.spec = evalfile (specname)
      return this.spec
    }
  }

  list : {
    specs : func {
      var verb = qualifier ("verbose", 1)
      var fp = qualifier ("out_stream", stdout) 
      var ar = this.spec_dir: dir_list ()
      return null if null is ar
      for |i, v| in ar
        ar[i] = v: path_basename_sans_extname ()
      return ar ifnot verb
      for |v| in ar
        println (fp, v)
    }
  }

  info : func {
    var msg =
      "PLATFORM         : " + this.platform + "\n" +
      "ARCHITECTURE     : " + this.arch     + "\n" +
      "SYSTEM DIRECTORY : " + this.sysdir   + "\n" +
      "BIN    DIRECTORY : " + this.bindir   + "\n" +
      "LIB    DIRECTORY : " + this.libdir   + "\n" +
      "BUILD  DIRECTORY : " + this.builddir + "\n" +
      "USER             : " + this.user     + "\n" +
      "GROUP            : " + this.group    + "\n"

    var verb = qualifier ("verbose", 1)
    var fp = qualifier ("out_stream", stdout)

    if verb then println (fp, msg)

    msg += 
      if this.spec isnot null then
        "\n" + this.spec:info (this; qualifiers ())
      orelse ""

    return msg ifnot verb
  }

  update_repo : func {
    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.spec.sources is null {
      println (stderr, "sources property hasn't been set")
      return notok
    }

    if this.spec.repo is null {
      println (stderr, "repo property hasn't been set")
      return notok
    }

    if this.git_exec is null {
      println (stderr, "git executable couldn't been found")
      return notok
    }

    var curdir = Dir.current ()

    return notok if notok is Dir.change (
      this.sources_dir: path_concat (this.spec.sources)

    var com = this.git_exec + " " + this.pull_args
    var retval = this.sh:exec (com)
    return notok if retval isnot ok
    return Dir.change (curdir)

  }

  build : func {
    var retval = notok

    if this.spec is null {
      println (stderr, "spec hasn't been set")
      return notok
    }

    if this.builddir is null {
      println (stderr, "builddir property hasn't been set")
      return notok
    }

    if this.builddir: dir_change () is notok {
      println (stderr, "couldn't change directory to ${%s, this.builddir}")
      return notok
    }

    if this.verbose is true {
      println ("Building " + this.spec.name)
      if this.spec.descr isnot null then println (this.spec.descr)
    }

    loop (1) {
      for |action| in this.spec.build {
        if this.verbose is true then
          ifnot null is action.msg then println (action.msg)

        if action.type is null or action.type < 0 or action.type > LAST_BUILD_TYPE {
          println (stderr, "the spec build type, hasn't been set properly")
          break 2
        }

        if action.type is PACKMAN_BUILD_EXTRACT {
          break 2 if notok is this.extract ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_COPY {
          break 2 if notok is this.copy_sources ()
          break 2 if notok is this.change_to_build_dirname ()
          continue
        }

        if action.type is PACKMAN_BUILD_MD_CHECK {
          var r = this.md_check (; verbose : 1)
          break 2 if notok is r
          ifnot r then break 2 ifnot null is this.spec.md
          continue
        }

        if action.type is PACKMAN_BUILD_CONFIGURE {
          var com = "./configure"
          ifnot (null is action.command) then
            com += format (" ${%s, format (action.command)}")

          if (this.sh:exec (com) isnot 0) {
            println (stderr, "error while executing command: ${%s, com}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE {
          var com = this.make_exec;
          ifnot (null is action.command) then
            com += format (" ${%s, format (action.command)}")

          if this.sh:exec (com) isnot 0 {
            println (stderr, "error while executing command: ${%s, com}")
            break 2
          }

          continue
        }

        if action.type is PACKMAN_BUILD_MAKE_INSTALL {
          var com = this.make_exec + " install";
          ifnot (null is action.command) then
            com += format (" ${%s, format (action.command)}")

          if this.sh:exec (com) isnot ok {
            println (stderr, "error while executing command: ${%s, com}")
            break 2
          }

          continue
        }

        continue if action.command is null

        if action.type is PACKMAN_BUILD_EVAL {
          println (Dir.current ());
          println (            action.command);
          var com = action.command
          __retval =  eval (com)
          println (__retval)
          #break 2 ifnot ok is action.command: eval ()
          continue
        }

        var com = format ("${%s, format (action.command)}")
        if this.sh:exec (com) isnot ok {
          println (stderr, "error while executing command: ${%s, com}")
          break 2
        }
      }

      retval = ok
    }

    Dir.change (this.curdir)
    return retval
  }
}
