var __me__ = __file__

     public const func libc_generate (argc, argv) {

import ("io")
import ("dir")
import ("std")
import ("file")
import ("path")

include ("argparse")

  const
  is_directory = dir_is_directory,
  realpath       = path_real,
  extname        = path_extname,
  dirname        = path_dirname,
  concat_with    = path_concat,
  basename       = path_basename,
  basename_without_extname = path_basename_sans_extname,
  filelines      = file_readlines,
  make_directory = dir_make,
  provide_str    = " provides: ",
  require_str    = "// requires: ",
  comment_str    = "// comment: ",
  end_str        = "// end"


  const
  thisDir      = __me__: dirname (),
  prog         = __me__: basename (),
  libcDir      = thisDir: concat_with ("libc"),
  default      = {
    dirname    :  thisDir: concat_with ("../../../libcmm"): realpath ()
    libname    :  "libc"
  }

  var argparse = New Argparse (4, 0, prog)
  argparse.add ("outputName",  0,  "outputName=",  "set output file name (default libc)",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("outputDir", 0, "outputDir=", "set output directory name (default gen$(outputName)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("verbose", 'v', "verbose=", "set verbosity", IntegerType, ARG_VALUE_OPTIONAL|ARG_VALUE_APPEND)
  argparse.add ("help", 'h', "help",  "show this message", BooleanType, 0)

  return notok ifnot ok is argparse.process (argv, 1)

  return ok if argparse.exit is true

  var verbose = argparse.results.verbose

  var outputName =
    argparse.results.outputName: if x is null then default.libname orelse x end
  var directoryName =
    argparse.results.outputDir:  if x is null then default.dirname orelse x end

  var outputDir = if directoryName : path_is_absolute () then directoryName orelse thisDir: concat_with (directoryName)
  ifnot outputDir: file_exists  () then make_directory (outputDir, 0755)

  ifnot outputDir: is_directory () {
    if verbose then println (stderr, "${outputDir}: is not a directory")
    return notok
  }

  var outputFile  = outputDir: concat_with (outputName + ".c")
  var licenceFile = outputDir: concat_with ("LICENSES")
  var commentFile = outputDir: concat_with ("comments")

  var dotsToLibc = lambda (d) {
    if d: path_is_absolute ()
      return thisDir: concat_with ("libc")

    var s = ""
    var p = d: tokenize ("/")
    for (var i = 0; i < p: len (); i++) {
      if i append "/" in s
      append ".." in s
    }

    append "/libc/libc" in s
    return s
  } (directoryName);

  var string[10] dirs = [
    "syscall", "std", "ctype", "signal", "stdlib", "string", "sys", "unistd",
    "time", "error"]

  var funcSigns = "\n/* Function Signatures */\n"
  var libcFuns  = "\n"
  var libcTypes = "\n    /* Types */\n"
  var licenses  = "\n    /* LICENSES */\n\n"
  var comments  = "\n    /* Comments */\n\n"
  var libcHdrs  =
   `/* Amalgamation oversimplified tiny libc for x86 and x86_64 */
    /* You get only what you only want, with a without magic code. */

    #ifndef LIBC_HDR
    #define LIBC_HDR

    #ifndef REQUIRE_STDINT
    #define REQUIRE_STDINT
    #endif

    #ifndef REQUIRE_NULL_H
    #define REQUIRE_NULL_H
    #endif

    #ifndef REQUIRE_SIZE_T_H
    #define REQUIRE_SIZE_T_H
    #endif

    #ifndef REQUIRE_ERRNO_H
    #define REQUIRE_ERRNO_H
    #endif

    #ifndef REQUIRE_ERRORS_H
    #define REQUIRE_ERRORS_H
    #endif

    #ifdef REQUIRE_STDINT
    #include <stdint.h>
    #endif

    /* Tracking Dependencies */

  `S4

  var filelist = {}

  Type Func {
    abspath
    header
    basedir
    endidx
    exttype
    funname
    depends
    init : func (abspath, header, basedir, endidx, exttype, funname) {
      this.abspath = abspath
      this.header  = header
      this.basedir = basedir
      this.endidx  = endidx
      this.exttype = exttype
      this.funname = funname
      this.depends = string[0]
    }
  } 

  for v in dirs {
    if v isnot "syscall" append format ("/* ${v} */") in libcFuns

    var dir = libcDir: concat_with (v)
    var arr = dir: dir_list ()

    for f in arr {
      var fn = dir: concat_with (f)
      var lines = fn: filelines ()

      if f: eq_n ("LICENSE_", 8) {
        var sp = f: advance_after_bytes ("LICENSE_", 1)
        append format ("/* ${sp} License */\n") in licenses
        for line in lines append line + "\n" in licenses
        append "\n" in licenses
        continue
      }

      if "syscall.c" is f {
        append "long syscall0 (long);\n" in funcSigns
        append "long syscall1 (long, long);\n" in funcSigns
        append "long syscall2 (long, long, long);\n" in funcSigns
        append "long syscall3 (long, long, long, long);\n" in funcSigns
        append "long syscall4 (long, long, long, long, long);\n" in funcSigns
        append "long syscall5 (long, long, long, long, long, long);\n" in funcSigns
        append "long syscall6 (long, long, long, long, long, long, long);\n" in funcSigns

        append "/* Syscalls Implementation */\n" in libcFuns

         # so we can open it with 'gf'
        append "/* " + (dotsToLibc: concat_with ("syscall/syscall.c")) + " */\n" in libcFuns

        for line in lines append line + '\n' in libcFuns
        append "\n" in libcFuns
        append "/* Function Implementation */\n" in libcFuns
        continue
      }

      var f_ext = f: extname (): to_upper (): advance (1)
      var f_hdr = f: basename_without_extname (): to_upper ()

      var idx = 0;
      var num_found = 0

      if "C" is f_ext {
        for (var i = idx; i < lines: len (); i++) {
          var line = lines[idx]
          var sp = line: bytes_in_str (provide_str)

          ifnot null is sp {
            num_found++
            # id[0]:  sometimes we need a "break that works for if's"
            #         else the logic may lost a bit, just because of
            #         the error conditional checks

            sp = sp: advance_after_bytes (provide_str, 1)

            ifnot (sp: len ()) {
              if verbose then println (stderr, "${v}/${f}: missing function signature")
            } else {
              ifnot num_found - 1 then
                append format ("\n#ifdef REQUIRE_${f_hdr}\n") in funcSigns
              append sp + if sp: eq_n ("#define ", 8) then "\n" orelse ";\n" end in funcSigns
            }
            idx++

          } else {
            ifnot num_found
              if verbose then println (stderr, "${v}/${f}: is missing a '// provides: ' token")
            break
          }
        }

        if num_found then append "#endif\n" in funcSigns
      }

      num_found = 0

      for (var i = idx; i < lines: len (); i++) {
        var line = lines[idx]
        var sp = line: bytes_in_str (require_str)
        break if null is sp

        sp = sp: advance_after_bytes (require_str, 1)
        var tok = sp: tokenize ("/")
        break if tok: len () < 1

        var unit = tok[-1]
        var ext = unit: extname (): to_upper (): advance (1)
        var hdr = unit: basename_without_extname () : to_upper ()

        var is_type_unit = "H" is ext

        ifnot num_found {
          append format ("#ifdef REQUIRE_${f_hdr}") in libcHdrs
          if "H" is f_ext then append "_H" in libcHdrs
          append "\n" in libcHdrs
        }

        append format ("  #ifndef REQUIRE_${hdr}") in libcHdrs
        if is_type_unit then append "_H" in libcHdrs
        append "\n" in libcHdrs
        append format ("  #define REQUIRE_${hdr}") in libcHdrs
        if is_type_unit then append "_H" in libcHdrs
        append "\n  #endif\n" in libcHdrs
        idx++
        num_found++
      }

      if num_found then append "#endif\n\n" in libcHdrs

      for (var i = idx; i < lines: len (); i++) {
        var line = lines[idx]
        var sp = line: bytes_in_str (comment_str)
        break if null is sp
        sp = sp: advance_after_bytes (comment_str, 1)
        append sp + "\n" in comments
        idx++
      }

      for (var i = idx; i < lines: len (); i++) {
        break if lines[i]: len ()
        idx++
      }

      if num_found and "H" is f_ext { # handle only types as functions have been forward declared
        var new = New Func (fn, f_hdr, v, idx, f_ext, f)
        append new in filelist as f
        continue
      }

      if "H" is f_ext {
        append format ("\n#ifdef REQUIRE_${f_hdr}") in libcTypes
        append "_H\n" in libcTypes
        append format ("/* ${dotsToLibc}/${v}/${f} */\n") in libcTypes

        for (var i = idx; i < lines: len (); i++) {
          break if lines[i]: eq_n ("// end", 6)
          append lines[i] + '\n' in libcTypes
        }

        append "#endif\n" in libcTypes
      } else {
        append format ("\n#ifdef REQUIRE_${f_hdr}\n") in libcFuns
        append format ("/* ${dotsToLibc}/${v}/${f} */\n") in libcFuns

        for (var i = idx; i < lines: len (); i++) {
          break if lines[i]: eq_n ("// end", 6)
          append lines[i] + '\n' in libcFuns
        }

        append "#endif\n" in libcFuns
      }
    }

    if v isnot "syscall" append format ("/* ${v} */\n\n") in libcFuns
  }

  for k, v in filelist {
    var lines = v.abspath: filelines ()
    var idx = v.endidx

    append format ("\n#ifdef REQUIRE_${v.header}") in libcTypes
    append "_H\n" in libcTypes
    append format ("/* ${dotsToLibc}/${v.basedir}/${v.funname} */\n") in libcTypes

    for (var i = idx; i < lines: len (); i++) {
      break if lines[i]: eq_n (end_str, 6)
      append lines[i] + '\n' in libcTypes
    }

    append "#endif\n" in libcTypes
  }

  append "#endif /* LIBC_HDR */\n" in libcFuns

  return notok if notok is File.write (outputFile, libcHdrs + libcTypes + funcSigns + libcFuns)
  return notok if notok is File.write (commentFile, comments)
  return notok if notok is File.write (licenceFile, licenses)
  return ok
}

# libc_generate (__argc, __argv)

func generatedLibc_help () {
  println (`Reserved tokens

// provides: [function signature], it is required when the unit is a function, and should be at the first line only
// requires: [dir/unit]
// comment: 
// end [ends the interpretation]`)
}

#generatedLibc_help ()
