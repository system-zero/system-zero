#@
  depends_on ("generate/errno", MODULE)
#

var m = New Make (__file__, LIBC)

func error_exit (msg) {
  println (stderr, msg)
  return notok
}

func libc_pre_exec (s) {
  var d = "libc/error"
  ifnot d: exists () then
    if mkdir (d, 0755; verbose : 1) is notok then
      return error_exit ("can not create libc/error directory")

  ifnot d: isdirectory () then return error_exit ("libc/error is not a directrory")

  var f = d: concat_with ("errors.h")

  if f: exists () {
    ifnot f: isregular () then
      return error_exit (f + " is not a regular file")

    return ok if s.get.libc.force () is false
  }

  import ("generateerrno")

  var e = Generate.errno ()

  var write_fd = open (f, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IROTH|S_IRGRP);
  if write_fd is null then return exit_error ("can not open(): " + f)

  for i, v in e.definitions {
    if notok is write (write_fd, "#ifndef " + v + "\n") return exit_error ("couldn't write to " + f)
    if notok is write (write_fd, "#define " + v + " " +
      if i isnot e.errors[i] then e.definitions[e.errors[i]] orelse e.errors[i]: to_string (10) end + "\n") return exit_error ("couldn't write to " + f)

    if notok is write (write_fd, "#endif /* " + v + " */\n") return exit_error ("couldn't write to " + f)
    if i + 1 isnot e.definitions: len ()
      if notok is write (write_fd, "\n") return exit_error ("couldn't write to " + f)
  }

  f = d: concat_with ("error_list.h")
  if f: exists () {
    ifnot f: isregular () then
      return error_exit (f + " is not a regular file")

    return ok if s.get.libc.force () is false
  }

  write_fd = open (f, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IROTH|S_IRGRP);
  if write_fd is null then return exit_error ("can not open(): " + f)

  var num = e.errors: len () - 5
  if notok is write (write_fd, "// requires: error/errors.h\n\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "#define LAST_ERROR " + num: to_string (10) + "\n\n") return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "static const struct sys_errorlist_type {\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "  const char *name;\n  const char *msg;\n  int errnum;\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "} sys_errorlist[] = {\n") then return exit_error ("couldn't write to " + f)

  for i, v in e.definitions {
    if notok is write (write_fd, "  { \"" + v + "\", \"" + e.strerrors[i] + "\", " +
      if i isnot e.errors[i] then e.definitions[e.errors[i]] orelse e.errors[i]: to_string (10) end + "},\n") return exit_error ("couldn't write to " + f)
  }

  if notok is write (write_fd, "};\n\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "static int get_error_num (int errnum) {\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "  if (LAST_ERROR < errnum || errnum < 0)\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "    return EUNKNOWN;\n\n  return errnum;\n}\n") then return exit_error ("couldn't write to " + f)

  f = d: concat_with ("errno_string.c")
  if f: exists () {
    ifnot f: isregular () then
      return error_exit (f + " is not a regular file")

    return ok if s.get.libc.force () is false
  }

  write_fd = open (f, O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IROTH|S_IRGRP);
  if write_fd is null then return exit_error ("can not open(): " + f)

  if notok is write (write_fd, "// provides: char *errno_string (int)\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "// requires: error/errors.h\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "// requires: error/error_list.h\n\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "char *errno_string (int errnum) {\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "  errnum = get_error_num (errnum);\n") then return exit_error ("couldn't write to " + f)
  if notok is write (write_fd, "  return (char *) sys_errorlist[errnum].msg;\n}\n") then return exit_error ("couldn't write to " + f)

  return ok
}

m.set.libc.pre_exec (libc_pre_exec)

m.set.libc.source ([
  "libc/ctype/isalpha.c",
  "libc/ctype/isascii.c",
  "libc/ctype/isdigit.c",
  "libc/ctype/islower.c",
  "libc/ctype/isprint.c",
  "libc/ctype/isspace.c",
  "libc/ctype/isupper.c",
  "libc/ctype/tolower.c",
  "libc/ctype/toupper.c",
  "libc/signal/sigaction.c",
  "libc/signal/sigaction.h",
  "libc/signal/sigprocmask.c",
  "libc/signal/sigset.h",
  "libc/std/environ.h",
  "libc/std/errno.h",
  "libc/std/stdarg.h",
  "libc/std/std.h",
  "libc/std/zenv.h",
  "libc/stdlib/alloc.c",
  "libc/stdlib/atoi.c",
  "libc/stdlib/getenv.c",
  "libc/string/memcpy.c",
  "libc/string/memset.c",
  "libc/string/snprintf.c",
  "libc/string/str_byte_copy.c",
  "libc/string/str_copy.c",
  "libc/string/str_copy_fmt.c",
  "libc/string/str_eq.c",
  "libc/string/str_eq_n.c",
  "libc/string/strcat.c",
  "libc/string/strchr.c",
  "libc/string/strlen.c",
  "libc/string/strncmp.c",
  "libc/string/strrchr.c",
  "libc/string/vsnprintf.c",
  "libc/sys/brk.c",
  "libc/sys/ioctl.c",
  "libc/sys/lstat.c",
  "libc/sys/mman.c",
  "libc/sys/mman.h",
  "libc/sys/pid.h",
  "libc/sys/stat.c",
  "libc/sys/stat.h",
  "libc/sys/types.h",
  "libc/sys/waitpid.c",
  "libc/syscall/syscall.c",
  "libc/time/gettimeofday.c",
  "libc/time/localtime.c",
  "libc/time/time.c",
  "libc/time/time.h",
  "libc/time/tp2tm.c",
  "libc/time/tzset.c",
  "libc/time/clock_settime.c",
  "libc/unistd/access.c",
  "libc/unistd/close.c",
  "libc/unistd/dup2.c",
  "libc/unistd/execve.c",
  "libc/unistd/fcntl.c",
  "libc/unistd/fcntl.h",
  "libc/unistd/fcntl3.c",
  "libc/unistd/fork.c",
  "libc/unistd/isatty.c",
  "libc/unistd/open.c",
  "libc/unistd/pipe.c",
  "libc/unistd/read.c",
  "libc/unistd/termios.h",
  "libc/unistd/write.c",
  "libc/error/errors.h",
  "libc/error/error_list.h",
  "libc/error/errno_string.c",
  "libc/convert/string_to_hexstring.c",
  "libc/convert/hexstring_to_string.c"])

return m
