#!/bin/env La

# An oversimplified make like utility, which is quite specific for this
# environment and its development flow (though there is some kind of an
# abstraction), so its nothing new and excited.

          public func Make (argc, argv) {

import ("io")
import ("sh")
import ("sys")
import ("dir")
import ("file")
import ("path")
import ("crypt")

include ("argparse")

func argparseNew () {
  var argparse = New Argparse (27, 0, "Make option[s] [directory]")
  argparse.add ("shared", 0, "shared", "make shared targets", BooleanType, ARG_LITERAL)
  argparse.add ("static", 0, "static", "make static targets", BooleanType, ARG_LITERAL)
  argparse.add ("shared_library", 0, "shared-library", "make shared library", BooleanType, ARG_LITERAL) 
  argparse.add ("shared_executable", 0, "shared-executable", "make shared executable", BooleanType, ARG_LITERAL)
  argparse.add ("shared_module", 0, "shared-module", "make shared module", BooleanType, ARG_LITERAL)
  argparse.add ("static_library", 0, "static-library", "make static library", BooleanType, ARG_LITERAL) 
  argparse.add ("static_executable", 0, "static-executable", "make static executable", BooleanType, ARG_LITERAL)
  argparse.add ("install_header", 0, "install-header", "install header", BooleanType, ARG_LITERAL)
  argparse.add ("install_script", 0, "install-script", "install script", BooleanType, ARG_LITERAL)
  argparse.add ("all", 0, "all", "make all targets", BooleanType, ARG_LITERAL)
  argparse.add ("force", 0, "force", "force making targets", BooleanType, 0)
  argparse.add ("recursive", 'R', "recursive", "apply the 'force' option recursively", BooleanType, 0)
  argparse.add ("remove_cache", 0, "remove-cache", "remove cached file", BooleanType, 0)
  argparse.add ("version", 0, "version=", "set version", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("march", 0, "march=", "set march (default native)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("optimization", 0, "optimization=", "set optimization (default -O2)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("cc", 0, "cc=", "set cc (default gcc)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("std", 0, "std=", "set C standard (default c11)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("bindir", 0, "bindir=", "set bin directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("libdir", 0, "libdir=", "set lib directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("incdir", 0, "incdir=", "set include directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("datadir", 0, "datadir=", "set data directiry",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("moddir", 0, "moddir=", "set module directory",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("no_rpath", 0, "unset-rpath", "unset rpath", BooleanType, 0)
  argparse.add ("no_debug", 0, "unset-debug", "unset debug C flags (default on)", BooleanType, 0)
  argparse.add ("verbose", 'v', "verbose", "set verbosity", BooleanType, 0)
  argparse.add ("help", 'h', "help", "show this message", BooleanType, 0)
  return argparse
}

const open              = io_open
const read              = io_fd_read
const write             = io_fd_write
const stat              = file_stat
const copy              = file_copy
const clear             = list_clear
const mkdir             = dir_make_parents
const change            = dir_change
const isdirectory       = dir_is_directory
const concat_with       = path_concat
const exists            = file_exists
const remove            = file_remove
const symlink           = file_symlink
const dirname           = path_dirname
const realpath          = path_real
const basename          = path_basename
const key_exists        = map_key_exists
const base64_encode     = crypt_base64_encode_file
const char              = integer_char
const advance           = string_advance

const VERSION           = "0.3"
const CC                = "gcc"
const STD11             = "c11"
const STD99             = "c99"
const STDANSI           = "c90"
const OPTIMIZATION      = "-O2"
const MARCH             = "-march=native"
const SYSDIR            = Sys.get ("SYSDIR")
const SYSDATADIR        = Sys.get ("DATADIR")
const LIBDIR            = SYSDIR:  concat_with ("lib")
const BINDIR            = SYSDIR:  concat_with ("bin")
const INCDIR            = SYSDIR:  concat_with ("include")
const ZLIBDIR           = LIBDIR:  concat_with ("z")
const ZINCDIR           = INCDIR:  concat_with ("z")
const MODDIR            = ZLIBDIR: concat_with ("la-modules")
const SHELL             = "zs"
const SHELLDATADIR      = SYSDATADIR: concat_with (SHELL + "/commands")
const DEBUG             = true
const NODEBUG           = false
const VERBOSE           = true
const NOVERBOSE         = false
const RPATH             = true
const NORPATH           = false
const SPEC              = ".build"
const CACHED            = ".cached"

const ALL               = (1 << 1)
const SHARED_LIBRARY    = (1 << 2)
const SHARED_EXECUTABLE = (1 << 3)
const SHARED            = (1 << 4)
const STATIC_LIBRARY    = (1 << 5)
const STATIC_EXECUTABLE = (1 << 6)
const STATIC            = (1 << 7)
const MODULE            = (1 << 8)
const SCRIPT            = (1 << 9)

const ARGPARSE          = null

Type Make {
  private
  name                      : null
  sh                        : New Shell ()
  bindir                    : BINDIR
  libdir                    : ZLIBDIR
  incdir                    : ZINCDIR
  moddir                    : MODDIR
  datadir                   : SYSDATADIR
  shelldatadir              : SHELLDATADIR
  make_shared_library       : false
  make_shared_module        : false
  make_shared_executable    : false
  make_static_library       : false
  make_static_executable    : false
  install_header            : false
  install_script            : false
  force_shared_library      : false
  force_shared_module       : false
  force_shared_executable   : false
  force_static_library      : false
  force_static_executable   : false
  force_header              : false
  force_script              : false
  verbose                   : false
  version                   : null
  cc                        : null
  std                       : null
  builddir                  : null
  header                    : null
  libname                   : null
  liboutput                 : null
  execoutput                : null
  curdir                    : null
  cached_file               : null
  cached                    : null
  recorded                  : null
  optimization              : null
  march                     : null
  retval                    : ok
  debug                     : DEBUG
  rpath                     : RPATH
  libdirs                   : list (ZLIBDIR, LIBDIR)
  includedirs               : list (ZINCDIR, INCDIR)
  shared_library_sources    : list ()
  shared_module_sources     : list ()
  shared_executable_sources : list ()
  static_library_sources    : list ()
  static_executable_sources : list ()
  script_sources            : list ()
  cflags                    : list ()
  linkagainst : {
    shared_library          : list ()
    shared_executable       : list ()
    shared_module           : list ()
    static_library          : list ()
    static_executable       : list ()
  }

  targets                   : 0

  init_cflags : func {
    for |v| in this.includedirs append "-I" + v      in this.cflags
    for |v| in this.libdirs     append "-L" + v      in this.cflags

    append "-Wall"                                   in this.cflags
    append "-fdollars-in-identifiers"                in this.cflags


    if this.cc is "clang" {
      append "-Wno-override-init"                    in this.cflags
      append "-Wno-unused-command-line-argument"     in this.cflags
    }

    if this.cc is "gcc" {
      append "-Wimplicit-fallthrough"                in this.cflags
      append "-Wrestrict"                            in this.cflags
    }

    if this.debug is DEBUG {
      append "-g"                                    in this.cflags
      append "-Wextra"                               in this.cflags
      append "-Wshadow"                              in this.cflags
      append "-Wunused-result"                       in this.cflags
      append "-Wunused-function"                     in this.cflags
      append "-Wunused-macros"                       in this.cflags
      append "-Wsign-compare"                        in this.cflags
      append "-Wpointer-arith"                       in this.cflags
      append "-Wreturn-type"                         in this.cflags
      append "-Wwrite-strings"                       in this.cflags
      append "-Wuninitialized"                       in this.cflags
      append "-Wmissing-declarations"                in this.cflags
      append "-Werror-implicit-function-declaration" in this.cflags
    }
  }

  change_to_build_directory : func {
    return ok if null is this.builddir
    this.retval = this.builddir: change ()
    return this.retval
  }

  set_options : func {
    this.make_shared_library       = ARGPARSE.results.shared_library
    this.make_shared_module        = ARGPARSE.results.shared_module
    this.make_shared_executable    = ARGPARSE.results.shared_executable
    this.make_static_library       = ARGPARSE.results.static_library
    this.make_static_executable    = ARGPARSE.results.static_executable
    this.install_header            = ARGPARSE.results.install_header
    this.install_script            = ARGPARSE.results.install_script

    if ARGPARSE.results.shared or ARGPARSE.results.all {
      this.make_shared_library    = true
      this.make_shared_executable = true
      this.make_shared_module     = true
    }

    if ARGPARSE.results.static or ARGPARSE.results.all {
      this.make_static_library    = true
      this.make_static_executable = true
    }

    if ARGPARSE.results.shared_module or ARGPARSE.results.shared_executable then
      this.make_shared_library = true

    if ARGPARSE.results.static_executable then
      this.make_static_library = true

    if this.make_shared_library or this.make_static_library then this.install_header = true

    ifnot null is ARGPARSE.results.version then this.version = ARGPARSE.results.version

    if ARGPARSE.results.remove_cache then
      if this.cached_file: exists () then
        remove (this.cached_file)

    this.verbose = ARGPARSE.results.verbose

    this.cc           = if ARGPARSE.results.cc           isnot null then ARGPARSE.results.cc  orelse CC
    this.std          = if ARGPARSE.results.std          isnot null then ARGPARSE.results.std orelse STD11
    this.march        = if ARGPARSE.results.march        isnot null then ARGPARSE.results.march orelse MARCH
    this.optimization = if ARGPARSE.results.optimization isnot null then "-" + ARGPARSE.results.optimization orelse OPTIMIZATION
    this.version      = if ARGPARSE.results.version      isnot null then ARGPARSE.results.version orelse VERSION
    this.debug        = if ARGPARSE.results.no_debug     then NODEBUG orelse DEBUG
    this.rpath        = if ARGPARSE.results.no_rpath     then NORPATH orelse RPATH

    if this.install_script is false and ARGPARSE.results.all then this.install_script = true

    if ARGPARSE.results.libdir  isnot null then this.set.libdir  (ARGPARSE.results.libdir)
    if ARGPARSE.results.incdir  isnot null then this.set.incdir  (ARGPARSE.results.incdir)
    if ARGPARSE.results.bindir  isnot null then this.set.bindir  (ARGPARSE.results.bindir)
    if ARGPARSE.results.moddir  isnot null then this.set.moddir  (ARGPARSE.results.moddir)
    if ARGPARSE.results.datadir isnot null {
      this.set.datadir (ARGPARSE.results.datadir)
      this.set.shelldatadir (ARGPARSE.results.datadir: concat_with (SHELL + "/commands"))
    }

    return ifnot ARGPARSE.results.force

    if ARGPARSE.results.shared or ARGPARSE.results.shared_library    or ARGPARSE.results.all then this.force_shared_library = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_module     or ARGPARSE.results.all then this.force_shared_module = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_executable or ARGPARSE.results.all then this.force_shared_executable = true
    if ARGPARSE.results.static or ARGPARSE.results.static_library    or ARGPARSE.results.all then this.force_static_library = true
    if ARGPARSE.results.static or ARGPARSE.results.static_executable or ARGPARSE.results.all then this.force_static_executable = true
    if ARGPARSE.results.shared or ARGPARSE.results.static            or ARGPARSE.results.install_header or ARGPARSE.results.all then this.force_header = true
    if ARGPARSE.results.all    or ARGPARSE.results.install_script    then this.force_script = true
  }

  record : func (sources) {
    if this.recorded is null then this.recorded = {}

    for |v| in sources {
      continue if key_exists (this.recorded, v)
      continue ifnot v: exists ()
      var st = v: stat ()
      var base = base64_encode (v)
      this.recorded.$(v) = { mtime : st.st_mtime, base : base }
    }
  }

  read_cached_file : func {
    if this.cached is null {
      var fd = open (this.cached_file, O_RDONLY, 0)
      return true if fd is null
      var s = read (fd)
      var r = eval (s)
      if r isnot ok {
        println ("${this.cached_file}: evaluation error")
        return notok
      }
    }

    return false
  }

  should_make : func (target, sources, force) {
    return true if force

    var type = target: typeof ()
    if type is ArrayType or type is ListType {
      for |v| in target ifnot v: exists () return true
    } else {
      return true ifnot target: exists ()
    }

    return true ifnot this.cached_file: exists ()

    var r = this.read_cached_file ()
    return notok if r is notok
    return true  if r is true

    for |v| in sources {
      return true ifnot   this.cached: key_exists (v)
      return true ifnot this.recorded: key_exists (v)

      return true if this.cached.$(v).mtime isnot this.recorded.$(v).mtime
      return true if this.cached.$(v).base  isnot this.recorded.$(v).base
    }

    return false
  }

  install_data : func (exec) {
    return ok if null is exec
    return notok if notok is this.change_to_build_directory ()

    var targetdir = this.shelldatadir: concat_with (exec)
    ifnot targetdir: exists () then mkdir (targetdir, 0700)
    ifnot targetdir: isdirectory () {
      println ("${targetdir}: not a directory")
      return notok
    }

    ifnot this.verbose then println ("  install data")

    var args = exec: concat_with ("args")
    if args: exists () then
      copy (args, targetdir; verbose : this.verbose + 1, force : 1)

    var flags = exec: concat_with ("flags")
    if flags: exists () then
      return copy (flags, targetdir; verbose : this.verbose + 1, force : 1)
  }

  endbuild : func (retval) {
    change (this.curdir)
    this.retval = retval
    return retval
  }

  init : func (unit, targets) {
    this.targets = targets

    var dir  = unit : dirname ()
    var name =   dir: basename ()

    this.name = name
    this.curdir = Dir.current ()

    this.set_options ()

    if this.targets & SHARED_LIBRARY or this.targets & SHARED then
      this.set.shared.library.to_linkagainst (this.name + "-" + this.version)

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      this.set.shared.executable.to_linkagainst (this.name + "-" + this.version)

    if this.targets & STATIC_LIBRARY or this.targets & STATIC then
      this.set.static.library.to_linkagainst (this.name + "-" + this.version)

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      this.set.static.executable.to_linkagainst (this.name + "-" + this.version)

    if this.targets & MODULE and (this.targets & SHARED_LIBRARY or this.targets & SHARED) then
      this.set.shared.module.to_linkagainst (this.name + "-" + this.version)

    this.set.libname                          (name)
    this.set.liboutput                        (name)
    this.set.builddir                         (dir)
    this.set.header                           (name + ".h")
    this.set.cached_file                      (this.builddir: concat_with (CACHED))
    this.set.shared_library_source            ("lib" + name + ".c")
    this.set.shared_module_source             (name + "-module.c")
    this.set.static_library_source            ("lib" + name + ".c")
    this.set.execoutput                       (char (name[0] - ('a' - 'A')) + advance (name, 1))
    this.set.script_source                    (char (name[0] - ('a' - 'A')) + advance (name, 1))
    this.set.shared_executable_source         (name + "_main.c")
    this.set.static_executable_source         (name + "_main.c")

    this.init_cflags ()
  }


  public
  main : func {
    if this.targets & SHARED_LIBRARY or this.targets & SHARED or
       this.targets & STATIC_LIBRARY or this.targets & STATIC
      return notok if this.install.header () is notok

    if this.targets & SHARED_LIBRARY or this.targets & SHARED then
      return notok if this.make.shared.library () is notok

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      return notok if this.make.shared.executable () is notok

    if this.targets & STATIC_LIBRARY or this.targets & STATIC then
      return notok if this.make.static.library () is notok

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      return notok if this.make.static.executable () is notok

    if this.targets & MODULE then
      return notok if this.make.shared.module () is notok

    if this.targets & SCRIPT then
      return notok if this.install.script () is notok

    return ok
  }

  write_record : func {
    return ok if null is this.recorded

    var fd = open (this.cached_file, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR)
    return notok if fd is null

    return notok if notok is write (fd, "this.cached = {\n")

    for |k, v| in this.recorded {
      return notok if notok is write (fd, "  \"" + k + "\" : {\n    mtime : ")
      return notok if notok is write (fd, format ("${v.mtime}"))
      return notok if notok is write (fd, "\n    base : \"" + v.base + "\"\n")
      return notok if notok is write (fd, "  }\n")
    }

    return write (fd, "}")
  }

  get : {
    version     : func return this.version
    retval      : func return this.retval
    dependencie : func return this.dependencies
    name        : func return this.name
  }

  set : {
    cc                       : func (c) ifnot null is c this.cc = c
    std                      : func (s) ifnot null is s this.std = s
    march                    : func (m) ifnot null is m this.march = m
    version                  : func (v) ifnot null is v this.version = v
    libname                  : func (l) ifnot null is l this.libname = l
    liboutput                : func (o) ifnot null is o this.liboutput = "lib" + o + "-" + this.version
    execoutput               : func (o) ifnot null is o this.execoutput = o
    optimization             : func (o) ifnot null is o this.optimization = o
    header                   : func (h) ifnot null is h this.header = h
    cached_file              : func (c) ifnot null is c this.cached_file = c
    cflag                    : func (f) ifnot null is f append f in this.cflags
    shared_library_source    : func (s) ifnot null is s append s in this.shared_library_sources
    shared_module_source     : func (s) ifnot null is s append s in this.shared_module_sources
    shared_executable_source : func (s) ifnot null is s append s in this.shared_executable_sources
    static_library_source    : func (s) ifnot null is s append s in this.static_library_sources
    static_executable_source : func (s) ifnot null is s append s in this.static_executable_sources
    script_source            : func (s) ifnot null is s append s in this.script_sources
    builddir                 : func (d) ifnot null is d this.builddir = d
    bindir                   : func (d) ifnot null is d this.bindir = d
    libdir                   : func (d) ifnot null is d this.libdir = d
    incdir                   : func (d) ifnot null is d this.incdir = d
    moddir                   : func (d) ifnot null is d this.moddir = d
    datadir                  : func (d) ifnot null is d this.datadir = d
    shelldatadir             : func (d) ifnot null is d this.shelldatadir = d

    shared : {
      library : {
        to_linkagainst       : func (l) ifnot null is l append "-l" + l in this.linkagainst.shared_library
      }
      executable : {
        to_linkagainst       : func (l) ifnot null is l append "-l" + l in this.linkagainst.shared_executable
      }
      module : {
        to_linkagainst       : func (l) ifnot null is l append "-l" + l in this.linkagainst.shared_module
      }
    }

    static : {
      library : {
        to_linkagainst       : func (l) ifnot null is l append "-l" + l in this.linkagainst.static_library
      }
      executable : {
        to_linkagainst       : func (l) ifnot null is l append "-l" + l in this.linkagainst.static_executable
      }
    }
  }

  clear : {
    cflags                    : func clear (this.cflags)
    shared_library_sources    : func clear (this.shared_library_sources)
    shared_module_sources     : func clear (this.shared_module_sources)
    shared_executable_sources : func clear (this.shared_executable_sources)
    static_library_sources    : func clear (this.static_library_sources)
    static_executable_sources : func clear (this.static_executable_sources)
    shared : {
      library : {
        to_linkagainst        : func clear (this.linkagainst.shared_library)
      }
      executable : {
        to_linkagainst        : func clear (this.linkagainst.shared_executable)
      }
      module : {
        to_linkagainst        : func clear (this.linkagainst.shared_module)
      }
    }
    static : {
      library : {
        to_linkagainst        : func clear (this.linkagainst.static_library)
      }
      executable : {
        to_linkagainst        : func clear (this.linkagainst.static_executable)
      }
    }
  }

  unset : {
    rpath                     : func this.rpath = NORPATH
  }

  install : {
    header : func {
      return notok if notok is this.change_to_build_directory ()

      this.record ([this.header])

      return ok if false is this.install_header
      return ok if null is this.header

      ifnot this.incdir: exists () then mkdir (this.incdir, 0755; verbose : this.verbose + 1)
      ifnot this.incdir: isdirectory () {
        println ("${this.incdir}: is not a directory")
        return notok
      }

      var to = this.incdir: concat_with (this.header);

      var r = this.should_make (to, [this.header], this.force_header)
      return notok if r is notok
      return ok if r is false

      r = copy (this.header, to; verbose : this.verbose + 1, force : 1)
      this.install_header = false
      return this.endbuild (r)
    }

    script : func {
      return notok if notok is this.change_to_build_directory ()
      return ok if null is this.script_sources

      var sources = list ()
      for |v| in this.script_sources append v + ".lai" in sources

      this.record (sources)

      return ok if false is this.install_script

      ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
      ifnot this.bindir: isdirectory () {
        println ("${this.bindir}: is not a directory")
        return notok
      }

      var targets = list ()

      for |v| in this.script_sources {
        append this.bindir: concat_with (v)             in targets
        append this.bindir: concat_with (v) + "-static" in targets
      }

      var r = this.should_make (targets, sources, this.force_script)
      return notok if r is notok
      return ok if r is false

      r = notok
      var idx = 0
      for |v| in sources {
        continue ifnot v: exists ()

        var read_fd = open (v, O_RDONLY, 0)
        continue if null is read_fd
        var script = read (read_fd)

        var output = targets[idx++]

        var write_fd = open (output, O_WRONLY|O_CREAT, S_IRWXU);
        ifnot null is write_fd { 
          if this.verbose then println ("install ${output}") orelse println ("  install scripts")
          write (write_fd, "#!/bin/env La-shared\n\n")
          write (write_fd, script)
          r = ok
        }

        output = targets[idx++]
        write_fd  = open (output, O_WRONLY|O_CREAT, S_IRWXU)
        ifnot null is write_fd {
          if this.verbose then println ("install ${output}")
          write (write_fd, "#!/bin/env La-static\n\n")
          write (write_fd, script)
          r = ok
        }
      }

      if r is ok then
        for |v| in this.script_sources this.install_data (v)

      return this.endbuild (r)
    }
  }

  make : {
    shared : {
      library : func {
        return notok if notok is this.change_to_build_directory ()

        this.record (this.shared_library_sources)

        return ok if false is this.make_shared_library

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory () {
          println ("${this.libdir}: is not a directory")
          return notok
        }

        var output = this.libdir: concat_with (this.liboutput + ".so")

        var r = this.should_make (output, this.shared_library_sources, this.force_shared_library)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for |v| in this.cflags                      if v isnot null append " " + v in com
        for |v| in this.linkagainst.shared_library  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir      in com

        append " -shared -fPIC" in com
        append " -o " + output  in com

        for |v| in this.shared_library_sources if v isnot null then append " " + v in com

        if this.verbose then println (com) orelse println ("  making the shared library")

        r = this.sh: exec (com)

        var to = this.libdir: concat_with ("lib" + this.libname + ".so")
        if ok is r then
          symlink (this.liboutput + ".so", to; verbose : this.verbose + 1, force : 1)

        this.make_shared_library = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (r)
      }

      executable: func {
        return notok if notok is this.change_to_build_directory ()

        this.record (this.shared_executable_sources)

        return ok if false is this.make_shared_executable

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
        ifnot this.bindir: isdirectory () {
          println ("${this.bindir}: is not a directory")
          return notok
        }

        var output = this.bindir: concat_with (this.execoutput + "-shared")

        var r = this.should_make (output, this.shared_executable_sources, this.force_shared_executable)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for |v| in this.cflags                         if v isnot null append " " + v in com
        for |v| in this.linkagainst.shared_executable  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir in com

        append " -o " + output in com

        for |v| in this.shared_executable_sources if v isnot null then append " " + v in com

        if this.verbose then println (com) orelse println ("  making the shared executable")

        r = this.sh: exec (com)

        var to = this.bindir: concat_with (this.execoutput)

        if ok is r {
          symlink (this.execoutput + "-shared", to; verbose : this.verbose + 1, force : 1)
          this.install_data (this.execoutput)
        }

        this.make_shared_executable = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (r)
      }

      module : func {
        return notok if notok is this.change_to_build_directory ()

        this.record (this.shared_module_sources)

        return ok if false is this.make_shared_module

        ifnot this.moddir: exists () then mkdir (this.moddir, 0755; verbose : this.verbose + 1)
        ifnot this.moddir: isdirectory () {
          println ("${this.moddir}: is not a directory")
          return notok
        }

        var output = this.libdir: concat_with ("la-modules/" + this.libname + "-module.so")

        var r = this.should_make (output, this.shared_module_sources, this.force_shared_module)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for |v| in this.cflags                     if v isnot null append " " + v in com
        for |v| in this.linkagainst.shared_module  if v isnot null append " " + v in com

        append " -shared -fPIC" in com
        append " -lla -lstring -lvmap -lvstring" in com
        append " -o " + output in com

        for |v| in this.shared_module_sources if v isnot null then append " " + v in com

        if this.verbose then println (com) orelse println ("  making the shared module")

        r = this.sh: exec (com)

        this.make_shared_module = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (r)
      }
    }

    static : {
      library : func {
        return notok if notok is this.change_to_build_directory ()

        this.record (this.static_library_sources)

        return ok if false is this.make_static_library

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory () {
          println ("${this.libdir}: is not a directory")
          return notok
        }

        var output = this.libdir: concat_with (this.liboutput + ".a")

        var r = this.should_make (output, this.static_library_sources, this.force_static_library)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        for |v| in this.static_library_sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com

        if this.cc isnot "tcc" then append " -z muldefs" in com

        for |v| in this.cflags                     if v isnot null append " " + v in com
        for |v| in this.linkagainst.static_library if v isnot null append " " + v in com

        append " -static -c" in com
        append " -o " + this.liboutput + ".o" in com

        if this.verbose then println (com) orelse println ("  making the static library")

        r = this.sh: exec (com)

        if ok is r {
          com = "ar rs " + output
          append " " + this.liboutput + ".o" in com
          if this.verbose then println (com)
          r = this.sh: exec (com)
          remove (this.liboutput + ".o")
        }

        this.make_static_library = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (r)
      }

      executable: func {
        return notok if notok is this.change_to_build_directory ()

        this.record (this.static_executable_sources)

        return ok if false is this.make_static_executable

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
        ifnot this.bindir: isdirectory () {
          println ("${this.bindir}: is not a directory")
          return notok
        }

        var output = this.bindir: concat_with (this.execoutput + "-static")

        var r = this.should_make (output, this.static_executable_sources, this.force_static_executable)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        for |v| in this.static_executable_sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com
        append " -static"              in com

        for |v| in this.cflags                        if v isnot null append " " + v in com
        for |v| in this.linkagainst.static_executable if v isnot null append " " + v in com

        append " -o " + output in com

        if this.verbose then println (com) orelse println ("  making the static executable")

        r = this.sh: exec (com)
        if r is ok
          this.install_data (output)

        this.make_static_executable = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (r)
      }
    }
  }
}

const DEPENDENCIES = {}
const Dependencies = {}
const TARGETS      = {}

func get_dependencies (dir) {
  return notok ifnot dir: exists ()

  var file = if dir: isdirectory () then dir: concat_with (SPEC): realpath () orelse dir: realpath ()

  return ok if DEPENDENCIES: key_exists (file)

  var dlen = DEPENDENCIES: len ()

  append { id : dlen + 1, targets : 0 } in DEPENDENCIES as file

  append { deps : string[0], targets : integer[0] } in Dependencies as file

  if TARGETS: key_exists (dir) then
    DEPENDENCIES.$(file).targets = TARGETS.$(dir).targets

  var fd = open (file, O_RDONLY, 0)
  return notok if fd is null

  var s = read (fd)

  var an = annotate_get (s)

  return notok if an is null
  return ok ifnot len (s)

  func depends_on (dep, targets) {

    func append_target (d) {
      if TARGETS: key_exists (d) then
         TARGETS.$(d).targets |= targets
      orelse
         append { targets : targets, initializedAs : null} in TARGETS as d

      if TARGETS.$(d).initializedAs isnot null {
        DEPENDENCIES.$(TARGETS.$(d).initializedAs).targets |= targets
      }
    }

    ifnot null is dep {
      for |k, v| in Dependencies {
        for |d| in v.deps {
          if dep is d {
            append_target (d)
            return ok
          }
        }
      }

      append dep in Dependencies.$(file).deps

      append_target (dep)
    }
  }

  return notok if notok is eval (an)

  return ok ifnot len (Dependencies.$(file).deps)

  for |d| in Dependencies.$(file).deps {
    if d isnot null then
      return notok if notok is get_dependencies (d)
  }

  return ok
}

  # main
  ARGPARSE = argparseNew ()

  return notok ifnot ok is ARGPARSE.process (argv, 1)
  return ok if ARGPARSE.exit is true

  var f = ifnot ARGPARSE.argc then SPEC orelse ARGPARSE.argv[0]: concat_with (SPEC)

  var FORCE       = ARGPARSE.results.force
  var RECUR       = ARGPARSE.results.recursive
  var SHARED_ALL  = ARGPARSE.results.shared
  var SHARED_LIB  = ARGPARSE.results.shared_library
  var SHARED_EXE  = ARGPARSE.results.shared_executable
  var SHARED_MOD  = ARGPARSE.results.shared_module
  var STATIC_ALL  = ARGPARSE.results.static
  var STATIC_LIB  = ARGPARSE.results.static_library
  var STATIC_EXE  = ARGPARSE.results.static_executable
  var INST_SCRIPT = ARGPARSE.results.install_script
  var DO_ALL      = ARGPARSE.results.all
  var verbose     = ARGPARSE.results.verbose

  func zero_argparse_results () {
    ARGPARSE.results.shared            = false
    ARGPARSE.results.static            = false
    ARGPARSE.results.force             = false
    ARGPARSE.results.recursive         = false
    ARGPARSE.results.shared_library    = false
    ARGPARSE.results.shared_executable = false
    ARGPARSE.results.shared_module     = false
    ARGPARSE.results.static_library    = false
    ARGPARSE.results.static_executable = false
    ARGPARSE.results.install_script    = false
    ARGPARSE.results.all               = false
  }

  func init_argparse_results (flag, is_the_last) {
    if is_the_last {
      ARGPARSE.results.force             = FORCE
      ARGPARSE.results.recursive         = RECUR
      ARGPARSE.results.shared            = SHARED_ALL
      ARGPARSE.results.shared_library    = SHARED_LIB
      ARGPARSE.results.shared_executable = SHARED_EXE
      ARGPARSE.results.shared_module     = SHARED_MOD
      ARGPARSE.results.static            = STATIC_ALL
      ARGPARSE.results.static_library    = STATIC_LIB
      ARGPARSE.results.static_executable = STATIC_EXE
      ARGPARSE.results.install_script    = INST_SCRIPT
      ARGPARSE.results.all               = DO_ALL
      return
    }

    zero_argparse_results ()

    if FORCE then
      if RECUR then
        ARGPARSE.results.force = true

    ARGPARSE.results.shared         = if flag & SHARED         then true orelse false
    ARGPARSE.results.shared_library = if flag & SHARED_LIBRARY then true orelse false
    ARGPARSE.results.shared_module  = if flag & MODULE         then true orelse false
    ARGPARSE.results.static         = if flag & STATIC         then true orelse false
    ARGPARSE.results.static_library = if flag & STATIC_LIBRARY then true orelse false
    ARGPARSE.results.install_script = if flag & SCRIPT         then true orelse false
  }

  return notok if notok is get_dependencies (f)

  var dlen = DEPENDENCIES: len ()
  var deps = string[dlen]

  for |k, v| in DEPENDENCIES deps[dlen - v.id] = k

  var retval = ok

  for |i, v| in deps {
    return notok ifnot v: exists ()

    var is_the_last = i is (dlen - 1)

    init_argparse_results (DEPENDENCIES.$(v).targets, is_the_last)

    if i then println ("")
    println ("Making: [ ${dirname (v): basename ()} ]")

    var s = evalfile (v)

    var r =  s.main ()

    if r isnot ok then println ("failed") orelse
      ifnot (verbose) then println ("done")

    return notok if r is notok

    s.write_record ()

    if notok is s.get.retval () then retval = notok
  }

  return retval
}

var r = Make (__argc, __argv)

exit (if r is ok then 0 orelse 1)
