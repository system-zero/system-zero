##[
  An oversimplified make like utility, which is quite specific for this
  environment and its development flow (though there is some kind of an
  abstraction), so its nothing new and excited, but it has a nice grammar!
##]

##[
  It can be used both as the main utility if it will be installed by itself,
  or as a library if the MAKE_AS_LIBRARY const/var has been declared before
  include it. If it is being used as an executable, the argv argument comes
  from the environment and the argument parsing starts from index 1, otherwise
  the argv argument is an array of strings and parsing starts from index zero.
  Other than that difference, the interface is the same.
##]

# Note that since this unit is also a vehicle for development, some constructs
# are sometimes by purpose, more complicated than they could be written

import ("io")
import ("os")
import ("sh")
import ("sys")
import ("dir")
import ("file")
import ("path")
import ("crypt")

include ("argparse")
include ("packman")
include ("Generate.libc")

          public const func Make (argv) {

func argparseNew () {
  var argparse = New Argparse (34, 0, "Make option[s] [directory]")
  argparse.add ("shared", 0, "shared", "make shared targets", BooleanType, ARG_LITERAL)
  argparse.add ("static", 0, "static", "make static targets", BooleanType, ARG_LITERAL)
  argparse.add ("shared_library", 0, "shared-library", "make shared library", BooleanType, ARG_LITERAL) 
  argparse.add ("shared_executable", 0, "shared-executable", "make shared executable", BooleanType, ARG_LITERAL)
  argparse.add ("shared_module", 0, "shared-module", "make shared module", BooleanType, ARG_LITERAL)
  argparse.add ("static_library", 0, "static-library", "make static library", BooleanType, ARG_LITERAL) 
  argparse.add ("static_executable", 0, "static-executable", "make static executable", BooleanType, ARG_LITERAL)
  argparse.add ("install_header", 0, "install-header", "install header", BooleanType, ARG_LITERAL)
  argparse.add ("install_script_lib", 0, "install-script-library", "install script library", BooleanType, ARG_LITERAL)
  argparse.add ("install_script_exec", 0, "install-script-executable", "install script executable", BooleanType, ARG_LITERAL)
  argparse.add ("all", 0, "all", "make all targets", BooleanType, ARG_LITERAL)
  argparse.add ("force", 'f', "force", "force making targets", BooleanType, 0)
  argparse.add ("recursive", 'R', "recursive", "apply the 'force' option recursively", BooleanType, 0)
  argparse.add ("remove_cache", 0, "remove-cache", "remove cached file", BooleanType, 0)
  argparse.add ("platform", 0, "platform=", "operating system (default: Os.platform ())", StringType, ARG_VALUE_REQUIRED; defval : Os.platform ())
  argparse.add ("version", 0, "version=", "set version", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("march", 0, "march=", "set march (default native)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("optimization", 0, "optimization=", "set optimization (default -O2)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("flags", 0, "flag=", "add definition", ListType, ARG_VALUE_REQUIRED|ARG_VALUE_APPEND)
  argparse.add ("cc", 0, "cc=", "set cc (default gcc)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("std", 0, "std=", "set C standard (default c11)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("bindir", 0, "bindir=", "set bin directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("libdir", 0, "libdir=", "set lib directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("incdir", 0, "incdir=", "set include directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("datadir", 0, "datadir=", "set data directiry",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("moddir", 0, "moddir=", "set module directory",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("no_rpath", 0, "unset-rpath", "unset rpath", BooleanType, 0)
  argparse.add ("no_debug", 0, "unset-debug", "unset debug C flags (default on)", BooleanType, 0)
  argparse.add ("no_local_env", 0, "no-local-env", "do not add local env in cflags ", BooleanType, 0)
  argparse.add ("dump_commands", 0, "dump-commands", "dump commands only", BooleanType, 0)
  argparse.add ("namespace", 0, "namespace=", "namespace (default z)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("local_spec", 0, "local-spec", "use .local.build and .local_cached.build", BooleanType, 0)
  argparse.add ("no_verbose", 0, "no-verbose", "unset verbosity", BooleanType, 0)
  argparse.add ("help", 'h', "help", "show this message", BooleanType, 0)
  return argparse
}

const open              = io_open
const read              = io_fd_read
const write             = io_fd_write
const stat              = file_stat
const copy              = file_copy
const clear             = list_clear
const change            = dir_change
const mkdir             = dir_make_parents
const isdirectory       = dir_is_directory
const exists            = file_exists
const remove            = file_remove
const symlink           = file_symlink
const isregular         = file_is_reg
const realpath          = path_real
const concat_with       = path_concat
const dirname           = path_dirname
const basename          = path_basename
const key_exists        = map_key_exists
const base64_encode     = crypt_base64_encode_file
const char              = integer_char
const advance           = string_advance

const PLATFORM
const VERSION           = "0.4.4"
const Z                 = "z"
const Y                 = "y"
const J                 = "j"
const D                 = "d"
const L                 = "l"
const X                 = "x"
const CC                = "gcc"
const STD11             = "c11"
const STD99             = "c99"
const STDANSI           = "c90"
const OPTIMIZATION      = "-O2"
const MARCH             = "-march=native"
const SYSDIR            = Sys.get ("SYSDIR")
const SRCDIR            = Sys.get ("SRCDIR")
const REPODIR           = (SRCDIR + "/.."): realpath ()
const HOMEDIR           = Sys.get ("HOME")
const SYSDATADIR        = Sys.get ("DATADIR")
const TMPDIR            = Sys.get ("TMPDIR")
const SYSTMPDIR         = "/tmp"
const USERNAME          = Sys.get ("USERNAME")
const GROUPNAME         = Sys.get ("GROUPNAME")
const ZSRCDIR           = SRCDIR:  concat_with (Z)
const YSRCDIR           = SRCDIR:  concat_with (Y)
const JSRCDIR           = SRCDIR:  concat_with (J)
const DSRCDIR           = SRCDIR:  concat_with (D)
const LSRCDIR           = SRCDIR:  concat_with (L)
const XSRCDIR           = SRCDIR:  concat_with (X)
const ZSRCLIBDIR        = ZSRCDIR: concat_with ("lib")
const ZSRCAPPDIR        = ZSRCDIR: concat_with ("app")
const ZSRCMODDIR        = ZSRCDIR: concat_with ("la-modules")
const YSRCPKGDIR        = YSRCDIR: concat_with ("pkg")
const JSRCPKGDIR        = JSRCDIR: concat_with ("pkg")
const DSRCPKGDIR        = DSRCDIR: concat_with ("pkg")
const LSRCPKGDIR        = LSRCDIR: concat_with ("pkg")
const XSRCPKGDIR        = XSRCDIR: concat_with ("pkg")
const LIBCSRCDIR        = YSRCPKGDIR: concat_with ("libc/libc")

const LIBDIR            = SYSDIR:  concat_with ("lib")
const BINDIR            = SYSDIR:  concat_with ("bin")
const INCDIR            = SYSDIR:  concat_with ("include")
const ZLIBDIR           = LIBDIR:  concat_with (Z)
const ZINCDIR           = INCDIR:  concat_with (Z)
const ZLADIR            = ZLIBDIR: concat_with ("la-lib")
const ZMODDIR           = ZLIBDIR: concat_with ("la-modules")
const YLIBDIR           = LIBDIR:  concat_with (Y)
const YINCDIR           = INCDIR:  concat_with (Y)
const YMODDIR           = YLIBDIR: concat_with ("l-modules")
const LIBCDEFNAME       = "libc"
const LIBCDEFDIR        = ZINCDIR
const LIBCOUTPUT        = LIBCDEFDIR: concat_with (LIBCDEFNAME + ".h")
const SHELL             = "zs"
const SHELLDATADIR      = SYSDATADIR: concat_with (SHELL + "/commands")
const EDITOR            = "E"
const PAGER             = "Pager"
const RPATH             = true
const NORPATH           = false
const INTERPRETER       = "La"
const SHARED_INTERPRETER= "La-shared"
const STATIC_INTERPRETER= "La-static"
const SPECNAME          = ".build"
const LOCAL_SPECNAME    = ".local.build"
const CACHEDNAME        = ".cached.build"
const LOCAL_CACHEDNAME  = ".local_cached.build"

var CUR_SPECNAME        = SPECNAME
var CUR_CACHEDNAME      = CACHEDNAME

const DEBUG             = true
const NODEBUG           = false
const VERBOSE           = true
const NOVERBOSE         = false

const IGNORE            = -2
const NONE              = 0
const ALL               = (1 << 1)
const SHARED_LIBRARY    = (1 << 2)
const SHARED_EXECUTABLE = (1 << 3)
const SHARED            = (1 << 4)
const STATIC_LIBRARY    = (1 << 5)
const STATIC_EXECUTABLE = (1 << 6)
const STATIC            = (1 << 7)
const MODULE            = (1 << 8)
const SCRIPT_EXECUTABLE = (1 << 9)
const SCRIPT_LIBRARY    = (1 << 10)
const PACKAGE           = (1 << 11)
const LIBC              = (1 << 12)
const C_HEADER          = (1 << 13)
const SCRIPT            = (SCRIPT_EXECUTABLE|SCRIPT_LIBRARY)
const EXECUTABLE        = (SHARED_EXECUTABLE|STATIC_EXECUTABLE)
const LIBRARY           = (SHARED_LIBRARY|STATIC_LIBRARY)

const COMPILE_ASSEMBLE_LINK = 1
const COMPILE_ASSEMBLE      = 2

const SHARED_TYPE       = 1
const STATIC_TYPE       = 2

const ARGPARSE

        Type Make {
  private
  retval          : ok
  sh              : New Shell ()
  bindir          : BINDIR
  libdir          : ZLIBDIR
  toplibdir       : LIBDIR
  incdir          : ZINCDIR
  moddir          : ZMODDIR
  lalibdir        : ZLADIR
  datadir         : SYSDATADIR
  shelldatadir    : SHELLDATADIR
  specname        : SPECNAME
  cachedname      : CACHEDNAME
  local_env       : true
  local_cflags    : true
  dump_commands   : false
  namespace       : Z
  modulesdirname  : "la-modules"
  verbose         : false
  debug           : DEBUG
  rpath           : RPATH
  libdirs         : {[]}
  includedirs     : {[]}
  cflags          : {[]}
  targets         : 0
  name
  orig_name
  version
  cc
  std
  builddir
  header
  libname
  liboutput
  curdir
  cached_file
  cached
  recorded
  optimization
  march

  shared : {
    library : {
      cflags       : {[]}
      sources      : {[]}
      linkagainst  : {[]}
      compile_type : COMPILE_ASSEMBLE_LINK
      force        : false
      make         : false
      pre_exec
      post_exec
    }

    module : {
      sources     : {[]} 
      cflags      : {[]}
      linkagainst : {[]}
      force       : false
      make        : false
      output
      pre_exec
      post_exec
    }

    executable : {
      sources     : {[]}
      cflags      : {[]}
      linkagainst : {[]}
      force       : false
      make        : false
      output
      completion  : true
      pre_exec
      post_exec
    }
  }

  static : {
    library : {
      sources      : {[]}
      cflags       : {[]}
      linkagainst  : {[]}
      force        : false
      make         : false
      compile_type : COMPILE_ASSEMBLE_LINK
      pre_exec
      post_exec
    }

    executable : {
      sources     : {[]}
      cflags      : {[]}
      linkagainst : {[]}
      force       : false
      make        : false
      output
      completion  : true
      pre_exec
      post_exec
    }
  }

  script : {
    executable : {
      sources   : {[]}
      force     : false
      install   : false
      interpr   : {
        shared
        static
      }
      completion : true
      curtype
      cursource
      curoutput
      pre_exec
      post_exec
    }

    library : {
      sources   : {[]}
      force     : false
      install   : false
      cursource
      curoutput
      pre_exec
      post_exec
    }
  }

  header : {
    sources : {[]}
    force   : false
    install : false
  }

  libc : {
    sources : {[]}
    force : false
    output
    pre_exec
    post_exec
  }

  init_local_cflags : func {
    return if this.local_cflags is false
    append "-DYNS" in this.cflags
  }

  init_include_dirs : func {
    if this.namespace is Z {
      append ZINCDIR in this.includedirs
      append YINCDIR in this.includedirs
    } else if this.namespace is Y {
      append YINCDIR in this.includedirs
      append ZINCDIR in this.includedirs
    }
    append INCDIR in this.includedirs
  }

  init_lib_dirs : func {
    if this.namespace is Z {
      append ZLIBDIR in this.libdirs
      append YLIBDIR in this.libdirs
    } else if this.namespace is Y {
      append YLIBDIR in this.libdirs
      append ZLIBDIR in this.libdirs
    }

    append LIBDIR in this.libdirs
  }

  init_cflags : func {
    for v in this.includedirs append "-I" + v        in this.cflags
    for v in this.libdirs     append "-L" + v        in this.cflags

    append "-Wall"                                   in this.cflags
    append "-Wno-override-init"                      in this.cflags

    if this.cc is "clang" then
      append "-Wno-unused-command-line-argument"     in this.cflags

    if this.cc is "gcc" {
      append "-Wimplicit-fallthrough"                in this.cflags
      append "-Wrestrict"                            in this.cflags
    }

    if this.debug is DEBUG {
      append "-g"                                    in this.cflags
      append "-Wextra"                               in this.cflags
      append "-Wshadow"                              in this.cflags
      append "-Wunused-result"                       in this.cflags
      append "-Wunused-function"                     in this.cflags
      append "-Wunused-macros"                       in this.cflags
      append "-Wsign-compare"                        in this.cflags
      append "-Wpointer-arith"                       in this.cflags
      append "-Wreturn-type"                         in this.cflags
      append "-Wwrite-strings"                       in this.cflags
      append "-Wuninitialized"                       in this.cflags
      append "-Wmissing-declarations"                in this.cflags
      append "-Werror-implicit-function-declaration" in this.cflags
    }

    append "-fdollars-in-identifiers"                in this.cflags
  }

  change_to_build_directory : func {
    return ok if null is this.builddir
    this.retval = this.builddir: change ()
    if notok is this.retval
       println (errno_string (errno))
    return this.retval
  }

  set_options : func {
    if ARGPARSE.results.no_local_env is true then this.set.local_env (false)

    this.set.namespace (ARGPARSE.results.namespace)

    this.shared.library.make       = ARGPARSE.results.shared_library
    this.shared.module.make        = ARGPARSE.results.shared_module
    this.shared.executable.make    = ARGPARSE.results.shared_executable
    this.static.library.make       = ARGPARSE.results.static_library
    this.static.executable.make    = ARGPARSE.results.static_executable
    this.header.install            = ARGPARSE.results.install_header
    this.script.executable.install = ARGPARSE.results.install_script_exec
    this.script.library.install    = ARGPARSE.results.install_script_lib

    if ARGPARSE.results.shared or ARGPARSE.results.all {
      this.shared.library.make    = true
      this.shared.executable.make = true
      this.shared.module.make     = true
    }

    if ARGPARSE.results.static or ARGPARSE.results.all {
      this.static.library.make    = true
      this.static.executable.make = true
    }

    if ARGPARSE.results.shared_module or ARGPARSE.results.shared_executable
      this.shared.library.make = true

    if ARGPARSE.results.static_executable
      this.static.library.make = true

    if this.shared.library.make or this.static.library.make
      this.header.install = true

    ifnot null is ARGPARSE.results.version
      this.version = ARGPARSE.results.version

    if ARGPARSE.results.remove_cache
      if this.cached_file: exists ()
        remove (this.cached_file)

    this.verbose = if ARGPARSE.results.no_verbose then 0 orelse 1

    this.cc           = if ARGPARSE.results.cc           isnot null then ARGPARSE.results.cc  orelse CC
    this.std          = if ARGPARSE.results.std          isnot null then ARGPARSE.results.std orelse STD11
    this.march        = if ARGPARSE.results.march        isnot null then ARGPARSE.results.march orelse MARCH
    this.optimization = if ARGPARSE.results.optimization isnot null then "-" + ARGPARSE.results.optimization orelse OPTIMIZATION
    this.version      = if ARGPARSE.results.version      isnot null then ARGPARSE.results.version orelse VERSION
    this.debug        = if ARGPARSE.results.no_debug     then NODEBUG orelse DEBUG
    this.rpath        = if ARGPARSE.results.no_rpath     then NORPATH orelse RPATH

    if ARGPARSE.results.flags isnot null then
      for v in ARGPARSE.results.flags
        append "-D" + v in this.cflags

    if this.script.executable.install is false and ARGPARSE.results.all
      this.script.executable.install = true

    if this.script.library.install is false and ARGPARSE.results.all
      this.script.library.install = true

    if ARGPARSE.results.libdir  isnot null
      this.set.libdir  (ARGPARSE.results.libdir)
    if ARGPARSE.results.incdir  isnot null
      this.set.incdir  (ARGPARSE.results.incdir)
    if ARGPARSE.results.bindir  isnot null
      this.set.bindir  (ARGPARSE.results.bindir)
    if ARGPARSE.results.moddir  isnot null
      this.set.moddir  (ARGPARSE.results.moddir)
    if ARGPARSE.results.datadir isnot null {
      this.set.datadir (ARGPARSE.results.datadir)
      this.set.shelldatadir (ARGPARSE.results.datadir: concat_with (SHELL + "/commands"))
    }

    if ARGPARSE.results.dump_commands is true
      this.set.dump_commands (true)

    if ARGPARSE.results.local_spec is true {
      this.specname = LOCAL_SPECNAME
      this.cachedname = LOCAL_CACHEDNAME
    } else {
      this.specname = CUR_SPECNAME
      this.cachedname = CUR_CACHEDNAME
    }

    return ifnot ARGPARSE.results.force

    if ARGPARSE.results.shared or ARGPARSE.results.shared_library    or ARGPARSE.results.all
      this.shared.library.force = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_module     or ARGPARSE.results.all
      this.shared.module.force = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_executable or ARGPARSE.results.all
      this.shared.executable.force = true
    if ARGPARSE.results.static or ARGPARSE.results.static_library    or ARGPARSE.results.all
      this.static.library.force = true
    if ARGPARSE.results.static or ARGPARSE.results.static_executable or ARGPARSE.results.all
      this.static.executable.force = true
    if ARGPARSE.results.shared_library or ARGPARSE.results.static_library or ARGPARSE.results.install_header or ARGPARSE.results.all
      this.header.force = true
    if ARGPARSE.results.all or ARGPARSE.results.install_script_exec
      this.script.executable.force = true
    if ARGPARSE.results.all or ARGPARSE.results.install_script_lib
      this.script.library.force = true
  }

  record : func (sources) {
    if this.recorded is null this.recorded = {}

    for v in sources {
      continue if
        key_exists (this.recorded, v)
      continue ifnot
         v: exists ()

      var st = v: stat ()
      var base = base64_encode (v)
      this.recorded.$(v) = { mtime : st.st_mtime, base : base }
    }

    var v = this.specname
    var st = v: stat ()
    var base = base64_encode (v)
    this.recorded.$(v) = { mtime : st.st_mtime, base : base }
  }

  read_cached_file : func {
    if this.cached is null {
      var fd = open (this.cached_file, O_RDONLY, 0)
      return true if
         fd is null

      var s = read (fd)
      if s is null
        return this.error ("can not read() " + this.cached_file)

      var r = eval (s)
      if r isnot ok
        return this.error (this.cached_file + " evaluation error")
    }

    return false
  }

  should_make : func (target, sources, force) {
    return true if force

    var type = target: typeof ()

    if type is ArrayType or type is ListType then
      for v in target
        return true ifnot
          v: exists ()
    orelse
      return true ifnot
        target: exists ()

    return true ifnot this.cached_file: exists ()

    var r = this.read_cached_file ()

    return notok if r is notok
    return true  if r is true

    for v in sources {
      return true ifnot this.cached:   key_exists (v)
      return true ifnot this.recorded: key_exists (v)

      return true if this.cached.$(v).mtime isnot this.recorded.$(v).mtime
      return true if this.cached.$(v).base  isnot this.recorded.$(v).base
    }

    var v = this.specname

    return true ifnot this.cached:   key_exists (v)
    return true ifnot this.recorded: key_exists (v)
    return true if    this.cached.$(v).mtime isnot this.recorded.$(v).mtime

    return false
  }

  install_data : func (exec) {
    return ok if null is exec
    return notok if notok is this.change_to_build_directory ()

    var targetdir = this.shelldatadir: concat_with (exec)

    ifnot targetdir: exists ()
      mkdir (targetdir, 0700)

    ifnot targetdir: isdirectory ()
      return this.error (targetdir + ": not a directory")

    ifnot this.verbose
      ifnot this.dump_commands
        println ("  install data")

    var args = exec: concat_with ("args")
    if args: exists ()
      return notok if
        notok is copy (args, targetdir; verbose : this.verbose + 1, force : 1)

    var flags = exec: concat_with ("flags")
    if flags: exists ()
      copy (flags, targetdir; verbose : this.verbose + 1, force : 1)

    var literal_args = exec: concat_with ("literal_args")
    if literal_args: exists ()
      return notok if
        notok is copy (literal_args, targetdir; verbose : this.verbose + 1, force : 1)
  }

  endbuild : func (retval) {
    change (this.curdir)
    this.retval = retval
    return retval
  }

  init : func (unit, targets) {
    var name = qualifier ("name", null)
    var cap_name

    var is_z_library = qualifier_exists ("z_library")
    var is_z_app = qualifier_exists ("z_app")
    var is_z_module = qualifier_exists ("z_module")

    this.targets = targets

    var dir = unit: dirname ()

    if null is name {
      if this.local_env and (is_z_library or is_z_app or is_z_module) {
        var base_name = dir: dirname (): basename ()
        this.orig_name = base_name

        if is_z_app {
          name = base_name
          cap_name = (char (name[0] - ('a' - 'A')) + if name: len () > 1 then advance (name, 1) orelse ""
        } else if is_z_library {
          name = (char (base_name[0] + ('a' - 'A')) +
            if base_name: len () > 1 then advance (base_name, 1) orelse ""
          if name: len () > 1 and name[1] < 'a' then name[1] = name[1] + ('a' - 'A')
          cap_name = base_name
        } else {
          name = base_name
          cap_name = (char (name[0] - ('a' - 'A')) + if name: len () > 1 then advance (name, 1) orelse ""
        }
      } else {
        name =  dir: basename ()
        this.orig_name = name
        cap_name = (char (name[0] - ('a' - 'A')) + if name: len () > 1 then advance (name, 1) orelse ""
      }
    } else {
      this.orig_name = name
    }

    this.name = name

    this.curdir = Dir.current ()

    return if targets is IGNORE

    this.set_options ()

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      this.set.shared.executable.to_linkagainst (this.name; append_version)

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      this.set.static.executable.to_linkagainst (this.name; append_version)

    if this.targets & MODULE and (this.targets & SHARED_LIBRARY or this.targets & SHARED) then
      this.set.shared.module.to_linkagainst (this.name; append_version)

    this.set.libname                   (name)
    this.set.liboutput                 (name)
    this.set.builddir                  (dir)
    this.set.cached_file               (this.builddir: concat_with (CACHEDNAME))
    this.set.header.source             (name + ".h"; clear)
    this.set.library.source            ("lib" + name + ".c")
    this.set.executable.source         (cap_name + ".c")
    this.set.executable.output         (cap_name)
    this.set.shared.module.source      (name + "-module.c")
    this.set.shared.module.output      (name)
    this.set.script.executable.source  (cap_name)
    this.set.script.library.source     (cap_name)
    this.set.libc.output               (LIBCOUTPUT)

    this.init_local_cflags ()
    this.init_include_dirs ()
    this.init_lib_dirs ()
    this.init_cflags ()
  }

  append_value : func (v, l) {
    return if null is v

    var t = v: typeof ()

    if t is ArrayType then
      for f in v
        append f in l
    orelse
      if t is StringType then
        append v in l
  }

  append_linkagainst_value : func (v, l) {
    return if null is v

    var append_version = qualifier_exists ("append_version")
    var t = v: typeof ()

    if t is ArrayType then
      for f in v append "-l" + f + (if append_version then "-" + this.version orelse "") in l
    orelse
      if t is StringType then
        append "-l" + v + (if append_version then "-" + this.version orelse "") in l
      orelse
         println (stderr, "append_linkagainst_value: ${typeAsString (v) is not a valid type")
  }

  make_objects_build_dir : func {
    ifnot "build": exists () then mkdir ("build", 0700)
    ifnot "build": isdirectory ()
      if false is this.dump_commands {
        println ("build: is not a directory")
        return notok
      }

    return ok
  }

  install : {
    header : func {
      return ok ifnot this.header.sources: len ()

      return notok if notok is this.change_to_build_directory () and this.dump_commands is false

      this.record (this.header.sources)

      return ok if false is this.header.install

      ifnot this.incdir: exists () then mkdir (this.incdir, 0755; verbose : this.verbose + 1)
      ifnot this.incdir: isdirectory ()
        if false is this.dump_commands {
          println ("${this.incdir}: is not a directory")
          return notok
        }

      var r = ok

      for h in this.header.sources {
        var to = this.incdir: concat_with (h)

        r = this.should_make (to, [h], this.header.force)
        return notok if r is notok
        continue if r is false

        if this.dump_commands {
          var ver = "-v "
          println ("# installing C header")
          println ("cp ${%s, this.verbose: if v is 1 then ver orelse `` end}--force ${this.header.sources} ${to}")
          continue
        }

        var dname = h: dirname ()
        if dname isnot "." {
          dname = this.incdir: concat_with (dname)
          return notok if notok is mkdir (dname, 0755; verbose : this.verbose + 1)
        }

        r = copy (h, to; verbose : this.verbose + 1, force : 1)
        return notok if r is notok
      }

      this.header.install = false
      return this.endbuild (r)
    }

    script : {
      executable : func {
        return ok if this.dump_commands
        return notok if notok is this.change_to_build_directory ()

        if null is this.script.executable.sources
          return this.error ("script executable sources is null")

        var sources = {[]}
        for v in this.script.executable.sources append v + ".lai" in sources

        this.record (sources)

        return ok if false is this.script.executable.install

        ifnot this.bindir: exists ()
          mkdir (this.bindir, 0755; verbose : this.verbose + 1)

        ifnot this.bindir: isdirectory ()
          if false is this.dump_commands
            return this.error (this.bindir + " is not a directory")

        var targets = {[]}

        for v in this.script.executable.sources {
          append this.bindir: concat_with (v)             in targets
          append this.bindir: concat_with (v) + "-static" in targets
        }

        var r = this.should_make (targets, sources, this.script.executable.force)

        return notok if r is notok
        return ok if r is false

        if null isnot this.script.executable.pre_exec {
          r = this.script.executable.pre_exec ()
          if r is notok then return this.error ("script executable pre_exec() callback returned an error, abort ...")
          return ok if r > ok
        }

        r = notok
        var idx = 0

        for v in sources {
          ifnot v: exists () then return this.error (v + " source doesn't exists")

          var read_fd = open (v, O_RDONLY, 0)
          if null is read_fd then return this.error ("unable to open() " + v)
          var script = read (read_fd)
          if null is script then return this.error ("unable to read() " + v)

          var interpr = SHARED_INTERPRETER

          ifnot null is this.script.executable.interpr.shared {
            var vv = v: path_basename_sans_extname ()
            for u, i in this.script.executable.interpr.shared {
              if u is vv {
                interpr = i
                break
              }
            }
          }

          var output = targets[idx++]

          var write_fd = open (output, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU);
          if null is write_fd then return this.error ("unable to open() " + output)

          this.script.executable.cursource = v
          this.script.executable.curtype = SHARED_TYPE
          this.script.executable.curoutput = output

          if null isnot this.script.executable.pre_exec {
            r = this.script.executable.pre_exec ()
            if r is notok then return this.error ("script executable pre_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          if this.verbose then println ("install ${output}") orelse println ("  install scripts")

          if notok is write (write_fd, "#!/bin/env " + interpr + "\n\n") then
            return this.error ("failed to write() on " + output)

          if notok is write (write_fd, script) then
            return this.error ("failed to write() on " + output)

          if null isnot this.script.executable.post_exec {
            r = this.script.executable.post_exec ()
            if r is notok then return this.error ("script executable post_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          interpr = STATIC_INTERPRETER

          ifnot null is this.script.executable.interpr.static {
            var vv = v: path_basename_sans_extname ()
            for u, i in this.script.executable.interpr.static {
              if u is vv {
                interpr = i
                break
              }
            }
          }

          output = targets[idx++]

          write_fd = open (output, O_WRONLY|O_CREAT|O_TRUNC, S_IRWXU)
          if null is write_fd then return this.error ("unable to open() " + output)

          this.script.executable.curoutput = output
          this.script.executable.curtype = STATIC_TYPE

          if null isnot this.script.executable.pre_exec {
            r = this.script.executable.pre_exec ()
            if r is notok then return this.error ("script executable pre_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          if this.verbose then println ("install ${output}")

          if notok is write (write_fd, "#!/bin/env " + interpr + "\n\n") then
            return this.error ("failed to write() on " + output)
          if notok is write (write_fd, script) then
            return this.error ("failed to write() on " + output)

          if null isnot this.script.executable.post_exec {
            r = this.script.executable.post_exec ()
            if r is notok then return this.error ("script executable post_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          r = ok
        }

        if r is ok then
          if this.script.executable.completion is true then
            for v in this.script.executable.sources this.install_data (v)

        return this.endbuild (r)
      }

      library : func {
        return ok if this.dump_commands
        return notok if notok is this.change_to_build_directory ()
        if null is this.script.library.sources then return this.error ("script library sources is null")

        var sources = {[]}
        for v in this.script.library.sources append v + ".lai" in sources

        this.record (sources)

        return ok if false is this.script.library.install

        ifnot this.lalibdir: exists () then mkdir (this.lalibdir, 0755; verbose : this.verbose + 1)

        ifnot this.lalibdir: isdirectory () then
          if false is this.dump_commands then return this.error (this.lalibdir + " is not a directory")

        var targets = {[]}

        for v in this.script.library.sources
          append this.lalibdir: concat_with (v + ".lai") in targets

        var r = this.should_make (targets, sources, this.script.library.force)

        return notok if r is notok
        return ok if r is false

        if null isnot this.script.library.pre_exec {
          r = this.script.library.pre_exec ()
          if r is notok then return this.error ("script library pre_exec() callback returned an error, abort ...")
          return ok if r > ok
        }

        r = notok
        var idx = 0

        for v in sources {
          ifnot v: exists ()
            return this.error (v + " source doesn't exists")

          var output = targets[idx++]

          this.script.library.cursource = v
          this.script.library.curoutput = output

          if null isnot this.script.library.pre_exec {
            r = this.script.library.pre_exec ()
            if r is notok then return this.error ("script library pre_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          if notok is copy (v, output; verbose : 2, force : 1) then
            return this.error ("can not install library")

          if null isnot this.script.library.post_exec {
            r = this.script.library.post_exec ()
            if r is notok then return this.error ("script library post_exec() callback function returned an error, abort ...")
            return ok if r > ok
          }

          if this.verbose then println ("install ${output}")

          r = ok
        }

        return this.endbuild (r)
      }
    }
  }

  make : {
    shared : {
      library : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared.library.sources)

        return ok if false is this.shared.library.make

        return notok if this.shared.library.compile_type < COMPILE_ASSEMBLE_LINK or
           this.shared.library.compile_type > COMPILE_ASSEMBLE

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory ()
          if false is this.dump_commands {
            println ("${this.libdir}: is not a directory")
            return notok
          }

        if this.shared.library.compile_type is COMPILE_ASSEMBLE then
          return this.compile.shared.library.objects ()

        var output = this.libdir: concat_with (this.liboutput + ".so")
        var r = this.should_make (output, this.shared.library.sources, this.shared.library.force)

        return notok if r is notok
        return ok if r is false

        if null isnot this.shared.library.pre_exec {
          r = this.shared.library.pre_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        var com = this.cc + " -std=" + this.std
        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                      if v isnot null append " " + v in com
        for v in this.shared.library.cflags       if v isnot null append " " + v in com
        for v in this.shared.library.linkagainst  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir      in com

        append " -shared -fPIC" in com
        append " -o " + output  in com

        for v in this.shared.library.sources
          if v isnot null then
            append " " + v in com

        if this.dump_commands {
          println ("# making the shared library")
          println (com)
          return ok
        }

        if this.verbose then
          println (com)
        orelse
          println ("  making the shared library")

        r = this.sh: exec (com)

        var to = this.libdir: concat_with (this.liboutput: delete_substr ("-" + this.version) + ".so")

        if ok is r then
          symlink (this.liboutput + ".so", to; verbose : this.verbose + 1, force : 1)

        this.shared.library.make = false

        if r is notok then
          println (" \e[31mfailed\e[m")
        orelse
          ifnot this.verbose then println ("  \e[32mdone\e[m")

        if r is ok and null isnot this.shared.library.post_exec {
          r = this.shared.library.post_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        return this.endbuild (if r isnot ok then notok orelse ok)
      }

      executable : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared.executable.sources)

        return ok if false is this.shared.executable.make

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)

        ifnot this.bindir: isdirectory ()
          if false is this.dump_commands {
            println ("${this.bindir}: is not a directory")
            return notok
          }

        var output = this.bindir: concat_with (this.shared.executable.output + "-shared")

        var r = this.should_make (output, this.shared.executable.sources, this.shared.executable.force)
        return notok if r is notok
        return ok if r is false

        if null isnot this.shared.executable.pre_exec {
          r = this.shared.executable.pre_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                         if v isnot null append " " + v in com
        for v in this.shared.executable.cflags       if v isnot null append " " + v in com
        for v in this.shared.executable.linkagainst  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir in com

        append " -o " + output in com

        for v in this.shared.executable.sources if v isnot null then append " " + v in com

        if this.dump_commands {
          println ("# making the shared executable")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the shared executable")

        r = this.sh: exec (com)

        var to = this.bindir: concat_with (this.shared.executable.output)

        if ok is r {
          symlink (this.shared.executable.output + "-shared", to; verbose : this.verbose + 1, force : 1)
          if this.shared.executable.completion is true then
            this.install_data (this.shared.executable.output)
        }

        this.shared.executable.make = false

        if r is notok then println (" \e[31mfailed\e[m") orelse
          ifnot this.verbose then println ("  \e[32mdone\e[m")

        if r is ok and null isnot this.shared.executable.post_exec {
          r = this.shared.executable.post_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }

      module : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared.module.sources)
        return ok if false is this.shared.module.make

        ifnot this.moddir: exists () then mkdir (this.moddir, 0755; verbose : this.verbose + 1)
        ifnot this.moddir: isdirectory () then
          if false is this.dump_commands then
            return this.error (this.moddir + ": is not a directory")

        var instdir = this.libdir: concat_with (this.modulesdirname)
        ifnot instdir: exists () then mkdir (instdir, 0755; verbose : this.verbose + 1)
        ifnot instdir: isdirectory () then
          if false is this.dump_commands then
            return this.error (this.moddir + ": is not a directory")

        var output = instdir: concat_with (this.shared.module.output + "-module.so")

        var r = this.should_make (output, this.shared.module.sources, this.shared.module.force)
        return notok if r is notok
        return ok if r is false

        if null isnot this.shared.module.pre_exec {
          r = this.shared.module.pre_exec ()
          return notok if r is notok
          return ok if r > ok
        }

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                     if v isnot null append " " + v in com
        for v in this.shared.module.cflags       if v isnot null append " " + v in com
        for v in this.shared.module.linkagainst  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir  + ":" + this.toplibdir    in com

        append " -shared -fPIC" in com
        append " -lla -lstring -lvmap -lvstring" in com
        append " -o " + output in com

        for v in this.shared.module.sources if v isnot null then append " " + v in com

        if this.dump_commands {
          println ("# making the shared module")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the shared module")

        r = this.sh: exec (com)

        this.shared.module.make = false

        if r is notok then println (" \e[31mfailed\e[m") orelse
          ifnot this.verbose then println ("  \e[32mdone\e[m")

        if r is ok and null isnot this.shared.module.post_exec {
          r = this.shared.module.post_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }
    }

    static : {
      library : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.static.library.sources)

        return ok if false is this.static.library.make

        return notok if this.static.library.compile_type < COMPILE_ASSEMBLE_LINK or
           this.static.library.compile_type > COMPILE_ASSEMBLE

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.libdir}: is not a directory")
            return notok
          }
        }

        if this.static.library.compile_type is COMPILE_ASSEMBLE then
          return this.compile.static.library.objects ()

        var output = this.libdir: concat_with (this.liboutput + ".a")

        var r = this.should_make (output, this.static.library.sources, this.static.library.force)
        return notok if r is notok
        return ok if r is false

        if null isnot this.static.library.pre_exec {
          r = this.static.library.pre_exec ()
          return notok if r is notok
          return ok if r > ok
        }

        var com = this.cc + " -std=" + this.std

        for v in this.static.library.sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com

        if this.cc isnot "tcc" then append " -z muldefs" in com

        for v in this.cflags                     if v isnot null append " " + v in com
        for v in this.static.library.cflags      if v isnot null append " " + v in com
        for v in this.static.library.linkagainst if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir in com

        append " -DSTATIC"                    in com
        append " -static -c"                  in com
        append " -o " + this.liboutput + ".o" in com

        if this.dump_commands {
          println ("# making the object")
          println (com)
          r = ok
        } else {

          if this.verbose then println (com) orelse println ("  making the static library")

          r = this.sh: exec (com)
        }

        if ok is r {
          com = "ar rs " + output
          append " " + this.liboutput + ".o" in com

          if this.dump_commands {
            println ("# making the static library")
            println (com)
            return ok
          }

          if this.verbose then println (com)
          r = this.sh: exec (com)
          remove (this.liboutput + ".o")
        }

        this.static.library.make = false

        if r is notok then println (" \e[31mfailed\e[m") orelse
          ifnot this.verbose then println ("  \e[32mdone\e[m")

        if r is ok and null isnot this.static.library.post_exec {
          r = this.static.library.post_exec ()
          return notok if r is notok
          return ok if r > ok
        } 

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }

      executable: func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.static.executable.sources)

        return ok if false is this.static.executable.make

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
        ifnot this.bindir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.bindir}: is not a directory")
            return notok
          }
        }

        var output = this.bindir: concat_with (this.static.executable.output + "-static")

        var r = this.should_make (output, this.static.executable.sources, this.static.executable.force)
        return notok if r is notok
        return ok if r is false

        if null isnot this.static.executable.pre_exec {
          r = this.static.executable.pre_exec ()
          return notok if r is notok
          return ok if r > ok
        }

        var com = this.cc + " -std=" + this.std

        for v in this.static.executable.sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com
        append " -DSTATIC"             in com
        append " -static"              in com

        if this.cc isnot "tcc" then append " -z muldefs" in com

        for v in this.cflags                        if v isnot null append " " + v in com
        for v in this.static.executable.cflags      if v isnot null append " " + v in com
        for v in this.static.executable.linkagainst if v isnot null append " " + v in com

        append " -o " + output in com

        if this.dump_commands {
          println ("# making the static executable")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the static executable")

        r = this.sh: exec (com)
        if r is ok then
          if this.static.executable.completion is true then
            this.install_data (this.static.executable.output)

        this.static.executable.make = false

        if r is notok then println (" \e[31mfailed\e[m") orelse
          ifnot this.verbose then println ("  \e[32mdone\e[m")

        if r is ok and null isnot this.static.executable.post_exec {
          r = this.static.executable.post_exec ()
          return notok if r is notok
          return ok if r > ok
        }

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }
    }

    libc : func {
      return notok if notok is this.change_to_build_directory ()
      ifnot this.libc.sources: len () return this.error ("libc sources array is null")

      this.record (this.libc.sources)

      this.libc.force = ARGPARSE.results.force

      var r = this.should_make (this.libc.output, this.libc.sources, this.libc.force)

      return notok if r is notok
      return ok if r is false

      if null isnot this.libc.pre_exec {
        r = this.libc.pre_exec ()
        return notok if r is notok
        return ok if r > ok
      }

      r = generate_libc (2, ["", (if this.verbose then "--verbose" orelse ""),
         "--outputDir=" + this.libc.output: dirname ()]);

      if r is notok return this.error ("failed to generate libc")

      if null isnot this.libc.post_exec {
        r = this.libc.post_exec ()
        return notok if r is notok
        return ok if r > ok
      }

      return r
    }
  }

  compile : {
    shared : {
      library : {
        objects : func {
          return notok if notok is this.make_objects_build_dir ()

          var com = this.cc + " -std=" + this.std

          append " " + this.march        in com
          append " " + this.optimization in com

          for v in this.cflags if v isnot null append " " + v in com

          append " -shared -fPIC" in com

          var string[this.shared.library.sources: len ()] objects

          for i, v in this.shared.library.sources {
            var oo = "build/" + v: path_basename_sans_extname () + ".o"
            objects[i] = oo
          }

          var n = 0

          var r
          for i, v in objects {
            r = this.should_make (v, [this.shared.library.sources[i]], this.shared.library.force)
            return notok if r is notok
            continue if r is false
            n++
            var lcom = com + " -c " + this.shared.library.sources[i] + " -o " + v

            if this.dump_commands {
              println (lcom)
              continue
            }

            if this.verbose then println (lcom)

            r = this.sh: exec (lcom)
            if r is notok {
              ifnot this.verbose then println (lcom)
              println ("failed")
              return notok
            }
          }

          return ok ifnot n

          for v in this.shared.library.cflags       if v isnot null append " " + v in com
          for v in this.shared.library.linkagainst  if v isnot null append " " + v in com

          if this.rpath then append " -Wl,-rpath=" + this.libdir in com

          for v in objects append " " + v in com

          var output = this.libdir: concat_with (this.liboutput + ".so")
          append " -o " + output in com

          if this.verbose then println (com)

          r = this.sh: exec (com)
          if r isnot ok {
            ifnot this.verbose then println (com)
            println ("failed")
            return notok
          }

          return this.endbuild (if r isnot ok then notok orelse ok end)
        }
      }
    }

    static : {
      library : {
        objects : func {
          return notok if notok is this.make_objects_build_dir ()

          var com = this.cc + " -std=" + this.std

          append " " + this.march        in com
          append " " + this.optimization in com

          if this.cc isnot "tcc" then append " -z muldefs" in com

          for v in this.cflags if v isnot null append " " + v  in com
          if this.rpath then append " -Wl,-rpath=" + this.libdir in com
          append " -DSTATIC -static" in com

          var string[this.static.library.sources: len ()] objects

          for i, v in this.static.library.sources {
            var oo = "build/" + (v: path_basename_sans_extname ()) + ".o"
            objects[i] = oo
          }

          var n = 0

          var r
          for i, v in objects {
            r = this.should_make (v, [this.static.library.sources[i]], this.static.library.force)
            return notok if r is notok
            continue if r is false
            n++
            var lcom = com + " -c " + this.static.library.sources[i] + " -o " + v

            if this.dump_commands {
              println (lcom)
              continue
            }

            if this.verbose then println (lcom)

            r = this.sh: exec (lcom)
            if r is notok {
              ifnot this.verbose then println (lcom)
              println ("failed")
              return notok
            }
          }

          return ok ifnot n

          var output = this.libdir: concat_with (this.liboutput + ".a")

          com = "ar rs " + output

          for v in objects append " " + v in com

          if this.verbose then println (com)
          r = this.sh: exec (com)

          r = this.sh: exec (com)
          if r is notok {
            ifnot this.verbose then println (com)
            println ("failed")
            return notok
          }

          remove ("build/" + this.liboutput + ".o")

          return this.endbuild (ok)
        }
      }
    }
  }

  public
  error : func (msg) {
    if msg isnot null
      println (stderr, msg)
    if errno
       println (stderr, errno_string (errno))
    return notok
  }

  main : func {
    return ok if this.targets is NONE
    return ok if this.targets is IGNORE

    if this.targets & PACKAGE {
      var p = New Packman ()
      p.set.build_dir (TMPDIR)
      p.new.spec (this.name)
      return notok if notok is p.build ()
    }

    if this.targets & LIBC
      return this.make.libc ()

    if this.targets & SHARED_LIBRARY or this.targets & SHARED or
       this.targets & STATIC_LIBRARY or this.targets & STATIC or
       this.targets & C_HEADER
      return notok if this.install.header () is notok

    if this.targets & SHARED_LIBRARY or this.targets & SHARED then
      return notok if this.make.shared.library () is notok

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      return notok if this.make.shared.executable () is notok

    if this.targets & STATIC_LIBRARY or this.targets & STATIC then
      return notok if this.make.static.library () is notok

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      return notok if this.make.static.executable () is notok

    if this.targets & MODULE then
      return notok if this.make.shared.module () is notok

    if this.targets & SCRIPT_EXECUTABLE then
      return notok if this.install.script.executable () is notok

    if this.targets & SCRIPT_LIBRARY then
      return notok if this.install.script.library () is notok

    return ok
  }

  write_record : func {
    return ok if null is this.recorded

    var fd = open (this.cached_file, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR)
    return notok if fd is null

    return notok if notok is write (fd, "this.cached = {\n")

    for k, v in this.recorded {
      return notok if notok is write (fd, "  \"" + k + "\" : {\n    mtime : ")
      return notok if notok is write (fd, format ("${v.mtime}"))
      return notok if notok is write (fd, "\n    base : \"" + v.base + "\"\n")
      return notok if notok is write (fd, "  }\n")
    }

    return write (fd, "}")
  }

  get : {
    cc            : func return this.cc
    sh            : func return this.sh
    name          : func return this.name
    orig_name     : func return this.orig_name
    version       : func return this.version
    verbose       : func return this.verbose
    retval        : func return this.retval
    libdir        : func return this.libdir
    bindir        : func return this.bindir
    toplibdir     : func return this.toplibdir
    shelldatadir  : func return this.shelldatadir
    targets       : func return this.targets
    dependencies  : func return this.dependencies
    dump_commands : func return this.dump_commands

    shared : {
      library : {
        force : func return this.shared.library.force
      }
      executable : {
        output : func return this.shared.executable.output
      }
    }

    static : {
      library : {
        force : func return this.static.library.force
      }
      executable : {
        output : func return this.static.executable.output
      }
    }

    script : {
      executable : {
        curoutput   : func return this.script.executable.curoutput
        curtype     : func return this.script.executable.curtype
        cursource   : func return this.script.executable.cursource
      }

      library : {
        curoutput   : func return this.script.executable.curoutput
        cursource   : func return this.script.executable.cursource
      }
    }

    libc : {
      force : func return this.libc.force
    }
  }

  set : {
    cc           : func (c) ifnot null is c this.cc = c
    std          : func (s) ifnot null is s this.std = s
    march        : func (m) ifnot null is m this.march = m
    version      : func (v) ifnot null is v this.version = v
    libname      : func (l) ifnot null is l this.libname = l
    liboutput    : func (o) ifnot null is o this.liboutput = "lib" + o + "-" + this.version
    optimization : func (o) ifnot null is o this.optimization = o
    cached_file  : func (c) ifnot null is c this.cached_file = c
    builddir     : func (d) ifnot null is d this.builddir = d
    bindir       : func (d) ifnot null is d this.bindir = d
    libdir       : func (d) ifnot null is d this.libdir = d
    incdir       : func (d) ifnot null is d this.incdir = d
    moddir       : func (d) ifnot null is d this.moddir = d
    lalibdir     : func (d) ifnot null is d this.lalibdir = d
    datadir      : func (d) ifnot null is d this.datadir = d
    shelldatadir : func (d) ifnot null is d this.shelldatadir = d

    dump_commands : func (v) this.dump_commands = v

    local_env : func (b) {
      this.local_env = b
      if this.local_env is false then this.local_cflags = false
    }

    modulesdirname : func (n) {
      return if null is n
      if this.local_env is false then this.modulesdirname = n
      orelse
        if Y is n then this.modulesdirname = "l-modules"
        orelse
          if  Z is n then this.modulesdirname = "la-modules"
          orelse this.modulesdirname = n
    }

    namespace : func (n) {
      return if null is n
      return if this.namespace is n
      this.namespace = n
      this.set.libdir (LIBDIR: concat_with (this.namespace))
      this.set.incdir (INCDIR: concat_with (this.namespace))
      this.set.modulesdirname (n)
    }

    cflags : func (v) this.append_value (v, this.cflags)

    shared : {
      library : {
        to_linkagainst : func (l) this.append_linkagainst_value (l, this.shared.library.linkagainst; qualifiers())
        cflag          : func (v) this.append_value (v, this.shared.library.cflags)
        pre_exec       : func (f) ifnot null is f then this.shared.library.pre_exec = f as callback
        post_exec      : func (f) ifnot null is f then this.shared.library.post_exec = f as callback
        compile_type   : func (t) this.shared.library.compile_type = t
        source         : func (v) {
          if qualifier_exists ("clear") then this.clear.shared.library.sources ()
          this.append_value (v, this.shared.library.sources)
        }
      }

      executable : {
        to_linkagainst : func (l) {
          if qualifier_exists ("clear") then this.clear.shared.executable.to_linkagainst()
          this.append_linkagainst_value (l, this.shared.executable.linkagainst; qualifiers())
        }

        cflag          : func (v) this.append_value (v, this.shared.executable.cflags)
        pre_exec       : func (f) ifnot null is f then this.shared.executable.pre_exec = f as callback
        post_exec      : func (f) ifnot null is f then this.shared.executable.post_exec = f as callback
        output         : func (o) ifnot null is o then this.shared.executable.output = o
        completion     : func (v) this.static.executable.completion = v
        source         : func (v) {
          if qualifier_exists ("clear") then this.clear.shared.executable.sources ()
          this.append_value (v, this.shared.executable.sources)
        }
      }

      module : {
        to_linkagainst : func (l) this.append_linkagainst_value (l, this.shared.module.linkagainst; qualifiers())
        cflag          : func (v) this.append_value (v, this.shared.module.cflags)
        pre_exec       : func (f) ifnot null is f then this.shared.module.pre_exec = f as callback
        post_exec      : func (f) ifnot null is f then this.shared.module.post_exec = f as callback
        output         : func (o) ifnot null is o this.shared.module.output = o
        source         : func (v) {
          if qualifier_exists ("clear") then this.clear.shared.module.sources ()
          this.append_value (v, this.shared.module.sources)
        }
      }

      cflags : func (v) {
        this.set.shared.library.cflag (v)
        this.set.shared.executable.cflag (v)
      }
    }

    static : {
      library : {
        to_linkagainst : func (l) this.append_linkagainst_value (l, this.static.library.linkagainst; qualifiers())
        cflag          : func (v) this.append_value (v, this.static.library.cflags)
        pre_exec       : func (f) ifnot null is f then this.static.library.pre_exec = f as callback
        post_exec      : func (f) ifnot null is f then this.static.library.post_exec = f as callback
        compile_type   : func (t) this.static.library.compile_type = t
        source         : func (v) {
          if qualifier_exists ("clear") then this.clear.static.library.sources ()
          this.append_value (v, this.static.library.sources)
        }
      }

      executable : {
        to_linkagainst : func (l) {
          if qualifier_exists ("clear") then this.clear.static.executable.to_linkagainst()
          this.append_linkagainst_value (l, this.static.executable.linkagainst; qualifiers())
        }

        cflag          : func (v) this.append_value (v, this.static.executable.cflags)
        pre_exec       : func (f) ifnot null is f then this.static.executable.pre_exec = f as callback
        post_exec      : func (f) ifnot null is f then this.static.executable.post_exec = f as callback
        output         : func (o) ifnot null is o then this.static.executable.output = o
        completion     : func (v) this.static.executable.completion = v
        source         : func (v) {
          if qualifier_exists ("clear") then this.clear.static.executable.sources ()
          this.append_value (v, this.static.executable.sources)
        }
      }

      cflags : func (v) {
        this.set.static.library.cflag (v)
        this.set.static.executable.cflag (v)
      }
    }

    script : {
      executable : {
        source : func (v) {
          if qualifier_exists ("clear") then this.clear.script.executable.sources ()
          this.append_value (v, this.script.executable.sources)
        }

        output : func (o) ifnot null is o then this.script.executable.output = o

        interpr : {
          shared : func (s, interpr) {
            if null is this.script.executable.interpr.shared then
              this.script.executable.interpr.shared = { $(s) : interpr }
            orelse
              this.script.executable.interpr.shared.$(s) = interpr
          }

          static : func (s, interpr) {
            if null is this.script.executable.interpr.static then
              this.script.executable.interpr.static = { $(s) : interpr }
            orelse
              this.script.executable.interpr.static.$(s) = interpr
          }
        }

        pre_exec  : func (f) ifnot null is f then this.script.executable.pre_exec = f as callback
        post_exec : func (f) ifnot null is f then this.script.executable.post_exec = f as callback

        completion : func (v) this script.executable.completion = v
      }

      library : {
        source : func (v) {
          if qualifier_exists ("clear") then this.clear.script.library.sources ()
          this.append_value (v, this.script.library.sources)
        }

        pre_exec  : func (f) ifnot null is f then this.script.library.pre_exec = f as callback
        post_exec : func (f) ifnot null is f then this.script.library.post_exec = f as callback
      }

      source : func (v) {
        this.set.script.executable.source (v; qualifiers ())
        this.set.script.library.source (v; qualifiers ())
      }
    }

    libc : {
      source : func (v) {
        if qualifier_exists ("clear") then this.clear.libc.sources ()
        this.append_value (v, this.libc.sources)
      }

      output    : func (o) ifnot null is o then this.libc.output = o
      pre_exec  : func (f) ifnot null is f then this.libc.pre_exec = f as callback
      post_exec : func (f) ifnot null is f then this.libc.post_exec = f as callback
    }

    header : {
      source : func (h) {
        if qualifier_exists ("clear") then this.clear.header.sources ()
        this.append_value (h, this.header.sources)
      }
    }

    library : {
      cflag : func (v) {
        this.set.shared.library.cflag (v)
        this.set.static.library.cflag (v)
      }

      to_linkagainst : func (l) {
        this.set.shared.library.to_linkagainst (l; qualifiers ())
        this.set.static.library.to_linkagainst (l; qualifiers ())
      }

      source : func (s) {
        this.set.shared.library.source (s; qualifiers ())
        this.set.static.library.source (s; qualifiers ())
      }
    }

    executable : {
      cflag : func (v) {
        this.set.shared.executable.cflag (v)
        this.set.static.executable.cflag (v)
      }

      output : func (o) {
        this.set.shared.executable.output (o)
        this.set.static.executable.output (o)
      }

      source : func (v) {
        this.set.shared.executable.source (v; qualifiers ())
        this.set.static.executable.source (v; qualifiers ())
      }

      to_linkagainst : func (l) {
        this.set.shared.executable.to_linkagainst (l; qualifiers ())
        this.set.static.executable.to_linkagainst (l; qualifiers ())
      }

      completion : func (v) {
        this.set.shared.executable.completion (v)
        this.set.static.executable.completion (v)
      }
    }
  }

  reset : {
    executable : {
      sources : {
        with  : func (v) {
          ifnot null is v {
            this.clear.shared.executable.sources ()
            this.clear.static.executable.sources ()
            this.set.shared.executable.source (v)
            this.set.static.executable.source (v)
          }
        }
      }
    }
  }

  clear : {
    cflags : func clear (this.cflags)

    shared : {
      library : {
        to_linkagainst : func clear (this.shared.library.linkagainst)
        cflags         : func clear (this.shared.library.cflags)
        sources        : func clear (this.shared.library.sources)
      }

      module : {
        to_linkagainst : func clear (this.shared.module.linkagainst)
        cflags         : func clear (this.shared.module.cflags)
        sources        : func clear (this.shared.module.sources)
      }

      executable : {
        to_linkagainst : func clear (this.shared.executable.linkagainst)
        cflags         : func clear (this.shared.executable.cflags)
        sources        : func clear (this.shared.executable.sources)
      }
    }

    static : {
      library : {
        to_linkagainst : func clear (this.static.library.linkagainst)
        cflags         : func clear (this.static.library.cflags)
        sources        : func clear (this.static.library.sources)
      }

      executable : {
        to_linkagainst : func clear (this.static.executable.linkagainst)
        cflags         : func clear (this.static.executable.cflags)
        sources        : func clear (this.static.executable.sources)
      }
    }

    script : {
      executable : {
        sources : func clear (this.script.executable.sources)
      }

      library : {
        sources : func clear (this.script.library.sources)
      }
    }

    libc   : { sources : func clear (this.libc.sources) }
    header : { sources : func clear (this.header.sources) }
  }

  filter: {
    shared : {
      executable : {
        to_linkagainst  : func (f) {
          for i, v in this.shared.executable.linkagainst  {
            if v is f {
              list_delete_at (this.shared.executable.linkagainst, i)
              i--
            }
          }
        }
      }
    }

    static : {
      executable : {
        to_linkagainst : func (f) {
          for i, v in this.static.executable.linkagainst {
            if v is f {
              list_delete_at (this.static.executable.linkagainst, i)
              i--
            }
          }
        }
      }
    }
  }

  unset : { rpath : func this.rpath = NORPATH }

}

const DEPENDENCIES = {}
func make_dependencies (f) {
  func get_dep_dir (d) {
    if d: exists () {
      if d: isdirectory return d
      return null
    }

    var p = d

    var n = JSRCPKGDIR: concat_with(d)
    ifnot n: exists () {
      n = YSRCPKGDIR: concat_with (d)
      ifnot n: exists () {
        n = DSRCPKGDIR: concat_with (d)
        ifnot n: exists () {
          n = LSRCPKGDIR: concat_with (d)
          ifnot n: exists () {
            n = XSRCPKGDIR: concat_with (d)
            ifnot n: exists () {
              n = ZSRCLIBDIR: concat_with (d): concat_with ("src")
              ifnot n: exists () {
                n = ZSRCAPPDIR: concat_with (d): concat_with ("src")
                if 0 is n: exists () or ARGPARSE.results.shared_module {
                  n = ZSRCMODDIR: concat_with (d)
                  return null ifnot n: exists ()
                }
              }
            }
          }
        }
      }
    }

    return if n: isdirectory () then n orelse null
  }

  func get_dep_spec (d) {
    var p = d
    ifnot d: exists () {
      var n = JSRCPKGDIR: concat_with(d)
      ifnot n: exists () {
        n = YSRCPKGDIR: concat_with (d)
        ifnot n: exists () {
          n = DSRCPKGDIR: concat_with (d)
          ifnot n: exists () {
            n = LSRCPKGDIR: concat_with (d)
            ifnot n: exists () {
              n = XSRCPKGDIR: concat_with (d)
              ifnot n: exists () {
                n = ZSRCLIBDIR: concat_with (d): concat_with ("src")
                ifnot n: exists () {
                  n = ZSRCAPPDIR: concat_with (d): concat_with ("src")
                  if 0 is n: exists () or ARGPARSE.results.shared_module {
                    n = ZSRCMODDIR: concat_with (d)
                    return null ifnot n: exists ()
                  }
                }
              }
            }
          }
        }
      }

      p = n
    }

    var file =
      if p: isdirectory () then
        p: concat_with (CUR_SPECNAME): realpath ()
      orelse
        p: realpath ()

    ifnot file: exists () {
      file =
        ifnot p: isdirectory () then p: concat_with (PLATFORM + CUR_SPECNAME): realpath ()
        orelse null
    }

    return null if file is null
    return null ifnot file: exists ()
    return file
  }

  const Dependencies = {}
  const TARGETS      = {}

  func append_target (d, targets) {

    if TARGETS: key_exists (d) {
      TARGETS.$(d).targets |= targets
    } else {
      var k = get_dep_spec (d)
      if k is null {
        println (stderr, "${d}: spec hasn't been found")
        return notok
      }

      append { targets : targets, initializedAs : k } in TARGETS as d
    }

    if TARGETS.$(d).initializedAs isnot null  {
      var t = TARGETS.$(d).initializedAs
      if DEPENDENCIES: key_exists (t) then
        DEPENDENCIES.$(t).targets |= targets
    }

    return ok
  }

  var nth = 0
  func get_dependencies (dir) {
    if nth and ARGPARSE.results.local_spec is true and
               ARGPARSE.results.recursive  isnot true {
      CUR_SPECNAME = SPECNAME
      CUR_CACHEDNAME = CACHEDNAME
    }

    nth++

    var file = get_dep_spec (dir)

    if file is null {
      println (stderr, "${dir}: spec hasn't been found")
      return notok
    }

    return ok if DEPENDENCIES: key_exists (file)

    var dlen = DEPENDENCIES: len ()

    append { id : dlen + 1, targets : 0 } in DEPENDENCIES as file

    append { deps : string[0], targets : integer[0] } in Dependencies as file

    var bname = dir: basename ()
    if TARGETS: key_exists (bname) then
      DEPENDENCIES.$(file).targets = TARGETS.$(bname).targets
    orelse
      if TARGETS: key_exists (dir) then
        DEPENDENCIES.$(file).targets = TARGETS.$(dir).targets

    var fd = open (file, O_RDONLY, 0)

    return notok if fd is null

    var s = read (fd)

    var an = annotate_get (s)
    return notok if an is null

    return ok ifnot len (s)

    func depends_on (dep, targets) {
      if null is dep return ok

      for k, v in Dependencies {
        for d in v.deps {
          if dep is d {
            __retval = append_target (d, targets)
            return __retval
          }
        }
      }

      append dep in Dependencies.$(file).deps

      return notok if notok is append_target (dep, targets)
    }

    func build_from (base, subdir, targets) {
      if null is base or null is subdir return ok
      var spec = get_dep_dir (base)
      if null is spec {
        println (stderr, "${base}: namespace hasn't been found")
        __retval = notok
        return __retval
      }

      var n = spec: concat_with (subdir)

      ifnot n: exists () {
        println (stderr, "${n}: doesn't exists")
         __retval = notok
         return __retval
      }

      ifnot n: isdirectory () {
        println (stderr, "${n}: is not a directoty")
         __retval = notok
         return __retval
      }

      spec = n: concat_with (CUR_SPECNAME): realpath ()

      ifnot spec: exists ()
        spec = n: concat_with (PLATFORM + CUR_SPECNAME): realpath ()

      if spec is null or 0 is spec: exists () {
        println (stderr, "${spec}: doesn't exists")
        __retval = notok
        return __retval
      }

      return depends_on (spec, targets)
    }

    return notok if notok is eval (an)

    return ok ifnot len (Dependencies.$(file).deps)

    for d in Dependencies.$(file).deps {
      if d isnot null then
        return notok if notok is get_dependencies (d)
    }

    return ok
  }

  return get_dependencies (f)
}

  return notok if argv: typeof () isnot ArrayType
  return notok ifnot argv: len ()

  ARGPARSE = argparseNew ()

  var start_index = if argv[0]: path_basename_sans_extname () is __func__ then 1 orelse 0

  return notok ifnot ok is ARGPARSE.process (argv, start_index)
  return ok if ARGPARSE.exit is true

  PLATFORM = ARGPARSE.results.platform

  var pkg = ifnot ARGPARSE.argc then Dir.current () orelse ARGPARSE.argv[0]

  var verbose          = if ARGPARSE.results.no_verbose then 0 orelse 1
  var DO_ALL           = ARGPARSE.results.all
  var FORCE            = ARGPARSE.results.force
  var RECUR            = ARGPARSE.results.recursive
  var SHARED_ALL       = ARGPARSE.results.shared
  var SHARED_LIB       = ARGPARSE.results.shared_library
  var SHARED_EXE       = ARGPARSE.results.shared_executable
  var SHARED_MOD       = ARGPARSE.results.shared_module
  var STATIC_ALL       = ARGPARSE.results.static
  var STATIC_LIB       = ARGPARSE.results.static_library
  var STATIC_EXE       = ARGPARSE.results.static_executable
  var INST_HEADER      = ARGPARSE.results.install_header
  var INST_SCRIPT_EXEC = ARGPARSE.results.install_script_exec
  var INST_SCRIPT_LIB  = ARGPARSE.results.install_script_lib
  var LOCALSPEC        = ARGPARSE.results.local_spec

  # do it twice as the time that is properly set, it might be already late
  if ARGPARSE.results.local_spec is true {
    CUR_SPECNAME = LOCAL_SPECNAME
    CUR_CACHEDNAME = LOCAL_CACHEDNAME
  }

  func zero_argparse_results () {
    ARGPARSE.results.all                 = false
    ARGPARSE.results.shared              = false
    ARGPARSE.results.static              = false
    ARGPARSE.results.force               = false
    ARGPARSE.results.recursive           = false
    ARGPARSE.results.shared_library      = false
    ARGPARSE.results.shared_executable   = false
    ARGPARSE.results.shared_module       = false
    ARGPARSE.results.static_library      = false
    ARGPARSE.results.static_executable   = false
    ARGPARSE.results.install_header      = false
    ARGPARSE.results.install_script_exec = false
    ARGPARSE.results.install_script_lib  = false
    ARGPARSE.results.local_spec          = false
  }

  func init_argparse_results (flag, is_the_last) {
    if is_the_last {
      ARGPARSE.results.all                 = DO_ALL
      ARGPARSE.results.force               = FORCE
      ARGPARSE.results.recursive           = RECUR
      ARGPARSE.results.shared              = SHARED_ALL
      ARGPARSE.results.shared_library      = SHARED_LIB
      ARGPARSE.results.shared_executable   = SHARED_EXE
      ARGPARSE.results.shared_module       = SHARED_MOD
      ARGPARSE.results.static              = STATIC_ALL
      ARGPARSE.results.static_library      = STATIC_LIB
      ARGPARSE.results.static_executable   = STATIC_EXE
      ARGPARSE.results.install_header      = INST_HEADER
      ARGPARSE.results.install_script_exec = INST_SCRIPT_EXEC
      ARGPARSE.results.install_script_lib  = INST_SCRIPT_LIB
      ARGPARSE.results.local_spec          = LOCALSPEC
      return
    }

    zero_argparse_results ()

    if FORCE then
      if RECUR then
        ARGPARSE.results.force = true

    if LOCALSPEC then
      if RECUR then
        ARGPARSE.results.local_spec = true

    ARGPARSE.results.shared         = if flag & SHARED or flag & ALL then true orelse false
    ARGPARSE.results.shared_library = if flag & SHARED_LIBRARY or flag & ALL then true orelse false
    ARGPARSE.results.shared_module  = if flag & MODULE or flag & ALL then true orelse false
    ARGPARSE.results.static         = if flag & STATIC or flag & ALL then true orelse false
    ARGPARSE.results.static_library = if flag & STATIC_LIBRARY or flag & ALL then true orelse false
    ARGPARSE.results.install_header = if flag & INST_HEADER or flag & ALL then true orelse false
    ARGPARSE.results.install_script_exec = if flag & SCRIPT_EXECUTABLE or flag & ALL then true orelse false
    ARGPARSE.results.install_script_lib  = if flag & SCRIPT_LIBRARY or flag & ALL then true orelse false
  }

  return notok if notok is make_dependencies (pkg)

  var dlen = DEPENDENCIES: len ()
  var deps = string[dlen]

  for k, v in DEPENDENCIES deps[dlen - v.id] = k

  var retval = ok

  ifnot deps: len () {
    println ("${pkg} package: not found")
    exit (1)
  }

  for i, v in deps {
    return notok ifnot v: exists ()

    var is_the_last = i is (dlen - 1)

    init_argparse_results (DEPENDENCIES.$(v).targets, is_the_last)

    var r = ok

    var s = evalfile (v)

    if null is s {
      r = notok
      print ("# Making: [ ${dirname (v): basename ()} ]")
    } else {
      ifnot s.get.targets () is IGNORE then
        println ("# Making: [\e[33m ${s.get.orig_name ()} \e[m]")
      r = s.main ()
    }

    if r isnot ok then println (" \e[31mfailed\e[m")
    orelse
      ifnot verbose then
        ifnot s.get.targets () is IGNORE then
          ifnot s.get.dump_commands then println ("\e[32mdone\e[m")

    return notok if r isnot ok

    s.write_record ()

    if notok is s.get.retval () then retval = notok
  }

  return retval
}
