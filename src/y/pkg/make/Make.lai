#!/bin/env La

# An oversimplified make like utility, which is quite specific for this
# environment and its development flow (though there is some kind of an
# abstraction), so its nothing new and excited.

          public const func Make (argc, argv) {

import ("io")
import ("sh")
import ("sys")
import ("dir")
import ("file")
import ("path")
import ("crypt")

include ("argparse")
include ("packman")

func argparseNew () {
  var argparse = New Argparse (31, 0, "Make option[s] [directory]")
  argparse.add ("shared", 0, "shared", "make shared targets", BooleanType, ARG_LITERAL)
  argparse.add ("static", 0, "static", "make static targets", BooleanType, ARG_LITERAL)
  argparse.add ("shared_library", 0, "shared-library", "make shared library", BooleanType, ARG_LITERAL) 
  argparse.add ("shared_executable", 0, "shared-executable", "make shared executable", BooleanType, ARG_LITERAL)
  argparse.add ("shared_module", 0, "shared-module", "make shared module", BooleanType, ARG_LITERAL)
  argparse.add ("static_library", 0, "static-library", "make static library", BooleanType, ARG_LITERAL) 
  argparse.add ("static_executable", 0, "static-executable", "make static executable", BooleanType, ARG_LITERAL)
  argparse.add ("install_header", 0, "install-header", "install header", BooleanType, ARG_LITERAL)
  argparse.add ("install_script", 0, "install-script", "install script", BooleanType, ARG_LITERAL)
  argparse.add ("all", 0, "all", "make all targets", BooleanType, ARG_LITERAL)
  argparse.add ("force", 'f', "force", "force making targets", BooleanType, 0)
  argparse.add ("recursive", 'R', "recursive", "apply the 'force' option recursively", BooleanType, 0)
  argparse.add ("remove_cache", 0, "remove-cache", "remove cached file", BooleanType, 0)
  argparse.add ("version", 0, "version=", "set version", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("march", 0, "march=", "set march (default native)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("optimization", 0, "optimization=", "set optimization (default -O2)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("cc", 0, "cc=", "set cc (default gcc)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("std", 0, "std=", "set C standard (default c11)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("bindir", 0, "bindir=", "set bin directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("libdir", 0, "libdir=", "set lib directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("incdir", 0, "incdir=", "set include directory", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("datadir", 0, "datadir=", "set data directiry",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("moddir", 0, "moddir=", "set module directory",  StringType, ARG_VALUE_REQUIRED)
  argparse.add ("no_rpath", 0, "unset-rpath", "unset rpath", BooleanType, 0)
  argparse.add ("no_debug", 0, "unset-debug", "unset debug C flags (default on)", BooleanType, 0)
  argparse.add ("no_local_env", 0, "no-local-env", "do not add local env in cflags ", BooleanType, 0)
  argparse.add ("dump_commands", 0, "dump-commands", "dump commands only", BooleanType, 0)
  argparse.add ("namespace", 0, "namespace=", "namespace (default z)", StringType, ARG_VALUE_REQUIRED)
  argparse.add ("local_spec", 0, "local-spec", "use .local.build and .local_cached.build", BooleanType, 0)
  argparse.add ("verbose", 'v', "verbose", "set verbosity", BooleanType, 0)
  argparse.add ("help", 'h', "help", "show this message", BooleanType, 0)
  return argparse
}

const open              = io_open
const read              = io_fd_read
const write             = io_fd_write
const stat              = file_stat
const copy              = file_copy
const clear             = list_clear
const mkdir             = dir_make_parents
const change            = dir_change
const isdirectory       = dir_is_directory
const concat_with       = path_concat
const exists            = file_exists
const remove            = file_remove
const symlink           = file_symlink
const dirname           = path_dirname
const realpath          = path_real
const basename          = path_basename
const key_exists        = map_key_exists
const base64_encode     = crypt_base64_encode_file
const char              = integer_char
const advance           = string_advance

const Z                 = "z"
const Y                 = "y"
const J                 = "j"
const VERSION           = "0.3"
const CC                = "gcc"
const STD11             = "c11"
const STD99             = "c99"
const STDANSI           = "c90"
const OPTIMIZATION      = "-O2"
const MARCH             = "-march=native"
const SYSDIR            = Sys.get ("SYSDIR")
const SYSDATADIR        = Sys.get ("DATADIR")
const SRCDIR            = Sys.get ("SRCDIR")
const TMPDIR            = Sys.get ("TMPDIR")
const ZSRCDIR           = SRCDIR:  concat_with (Z)
const YSRCDIR           = SRCDIR:  concat_with (Y)
const JSRCDIR           = SRCDIR:  concat_with (J)
const ZSRCLIBDIR        = ZSRCDIR: concat_with ("lib")
const ZSRCAPPDIR        = ZSRCDIR: concat_with ("app")
const YSRCPKGDIR        = YSRCDIR: concat_with ("pkg")
const JSRCPKGDIR        = JSRCDIR: concat_with ("pkg")
const LIBDIR            = SYSDIR:  concat_with ("lib")
const BINDIR            = SYSDIR:  concat_with ("bin")
const INCDIR            = SYSDIR:  concat_with ("include")
const ZLIBDIR           = LIBDIR:  concat_with (Z)
const ZINCDIR           = INCDIR:  concat_with (Z)
const ZMODDIR           = ZLIBDIR: concat_with ("la-modules")
const YLIBDIR           = LIBDIR:  concat_with (Y)
const YINCDIR           = INCDIR:  concat_with (Y)
const YMODDIR           = YLIBDIR: concat_with ("l-modules")
const LIBCNAME          = "libcmm"
const SHELL             = "zs"
const SHELLDATADIR      = SYSDATADIR: concat_with (SHELL + "/commands")
const RPATH             = true
const NORPATH           = false
const SCRIPT_INTERPRETER= "La-shared"
const SPEC              = ".build"
const LOCAL_SPEC        = ".local.build"
var   SPECNAME          = SPEC
const CACHED            = ".cached.build"
const LOCAL_CACHED      = ".local_cached.build"
var   CACHEDNAME        = CACHED

const DEBUG             = true
const NODEBUG           = false
const VERBOSE           = true
const NOVERBOSE         = false

const IGNORE            = -2
const ALL               = (1 << 1)
const SHARED_LIBRARY    = (1 << 2)
const SHARED_EXECUTABLE = (1 << 3)
const SHARED            = (1 << 4)
const STATIC_LIBRARY    = (1 << 5)
const STATIC_EXECUTABLE = (1 << 6)
const STATIC            = (1 << 7)
const MODULE            = (1 << 8)
const SCRIPT            = (1 << 9)
const PACKAGE           = (1 << 10)
const LIBC              = (1 << 11)
const EXECUTABLE        = (SHARED_EXECUTABLE|STATIC_EXECUTABLE)

const COMPILE_ASSEMBLE_LINK = 1
const COMPILE_ASSEMBLE      = 2

const ARGPARSE          = null

Type Make {
  private
  name                        : null
  sh                          : New Shell ()
  bindir                      : BINDIR
  libdir                      : ZLIBDIR
  toplibdir                   : LIBDIR
  incdir                      : ZINCDIR
  moddir                      : ZMODDIR
  datadir                     : SYSDATADIR
  shelldatadir                : SHELLDATADIR
  local_env                   : true
  local_cflags                : true
  make_shared_library         : false
  make_shared_module          : false
  make_shared_executable      : false
  make_static_library         : false
  make_static_executable      : false
  install_header              : false
  install_script              : false
  install_package             : false
  force_shared_library        : false
  force_shared_module         : false
  force_shared_executable     : false
  force_static_library        : false
  force_static_executable     : false
  force_header                : false
  force_script                : false
  dump_commands               : false
  shared_library_compile_type : COMPILE_ASSEMBLE_LINK
  static_library_compile_type : COMPILE_ASSEMBLE_LINK
  namespace                   : Z
  modulesdirname              : "la-modules"
  verbose                     : false
  version                     : null
  cc                          : null
  std                         : null
  builddir                    : null
  header                      : null
  libname                     : null
  liboutput                   : null
  execoutput                  : null
  moduleoutput                : null
  script_interpr              : null
  curdir                      : null
  cached_file                 : null
  cached                      : null
  recorded                    : null
  optimization                : null
  march                       : null
  retval                      : ok
  debug                       : DEBUG
  rpath                       : RPATH
  libdirs                     : {[]}
  includedirs                 : {[]}
  shared_library_sources      : {[]}
  shared_module_sources       : {[]}
  shared_executable_sources   : {[]}
  static_library_sources      : {[]}
  static_executable_sources   : {[]}
  script_sources              : {[]}
  libc_sources                : {[]}
  cflags                      : {[]}

  shared_library    : { cflags : {[]} }
  shared_module     : { cflags : {[]} }
  shared_executable : { cflags : {[]} }
  static_library    : { cflags : {[]} }
  static_executable : { cflags : {[]} }

  linkagainst       : {
    shared_library            : {[]}
    shared_executable         : {[]}
    shared_module             : {[]}
    static_library            : {[]}
    static_executable         : {[]}
  }

  targets                     : 0

  init_local_cflags : func {
    return if this.local_cflags is false
    append "-DYNS"                                   in this.cflags
  }

  init_include_dirs : func {
    if this.namespace is Z {
      append ZINCDIR in this.includedirs
      append YINCDIR in this.includedirs
    } else if this.namespace is Y {
      append YINCDIR in this.includedirs
      append ZINCDIR in this.includedirs
    }
    append INCDIR in this.includedirs
  }

  init_lib_dirs : func {
    if this.namespace is Z {
      append ZLIBDIR in this.libdirs
      append YLIBDIR in this.libdirs
    } else if this.namespace is Y {
      append YLIBDIR in this.libdirs
      append ZLIBDIR in this.libdirs
    }

    append LIBDIR in this.libdirs
  }

  init_cflags : func {
    for v in this.includedirs append "-I" + v        in this.cflags
    for v in this.libdirs     append "-L" + v        in this.cflags

    append "-Wall"                                   in this.cflags
    append "-Wno-override-init"                      in this.cflags

    if this.cc is "clang" {
      append "-Wno-unused-command-line-argument"     in this.cflags
    }

    if this.cc is "gcc" {
      append "-Wimplicit-fallthrough"                in this.cflags
      append "-Wrestrict"                            in this.cflags
    }

    if this.debug is DEBUG {
      append "-g"                                    in this.cflags
      append "-Wextra"                               in this.cflags
      append "-Wshadow"                              in this.cflags
      append "-Wunused-result"                       in this.cflags
      append "-Wunused-function"                     in this.cflags
      append "-Wunused-macros"                       in this.cflags
      append "-Wsign-compare"                        in this.cflags
      append "-Wpointer-arith"                       in this.cflags
      append "-Wreturn-type"                         in this.cflags
      append "-Wwrite-strings"                       in this.cflags
      append "-Wuninitialized"                       in this.cflags
      append "-Wmissing-declarations"                in this.cflags
      append "-Werror-implicit-function-declaration" in this.cflags
    }

    append "-fdollars-in-identifiers"                in this.cflags
  }

  change_to_build_directory : func {
    return ok if null is this.builddir
    this.retval = this.builddir: change ()
    return this.retval
  }

  set_options : func {
    if ARGPARSE.results.no_local_env is true then this.set.local_env (false)

    this.set.namespace (ARGPARSE.results.namespace)

    this.make_shared_library       = ARGPARSE.results.shared_library
    this.make_shared_module        = ARGPARSE.results.shared_module
    this.make_shared_executable    = ARGPARSE.results.shared_executable
    this.make_static_library       = ARGPARSE.results.static_library
    this.make_static_executable    = ARGPARSE.results.static_executable
    this.install_header            = ARGPARSE.results.install_header
    this.install_script            = ARGPARSE.results.install_script

    if ARGPARSE.results.shared or ARGPARSE.results.all {
      this.make_shared_library    = true
      this.make_shared_executable = true
      this.make_shared_module     = true
    }

    if ARGPARSE.results.static or ARGPARSE.results.all {
      this.make_static_library    = true
      this.make_static_executable = true
    }

    if ARGPARSE.results.shared_module or ARGPARSE.results.shared_executable then
      this.make_shared_library = true

    if ARGPARSE.results.static_executable then
      this.make_static_library = true

    if this.make_shared_library or this.make_static_library then this.install_header = true

    ifnot null is ARGPARSE.results.version then this.version = ARGPARSE.results.version

    if ARGPARSE.results.remove_cache then
      if this.cached_file: exists () then
        remove (this.cached_file)

    this.verbose = ARGPARSE.results.verbose

    this.cc           = if ARGPARSE.results.cc           isnot null then ARGPARSE.results.cc  orelse CC
    this.std          = if ARGPARSE.results.std          isnot null then ARGPARSE.results.std orelse STD11
    this.march        = if ARGPARSE.results.march        isnot null then ARGPARSE.results.march orelse MARCH
    this.optimization = if ARGPARSE.results.optimization isnot null then "-" + ARGPARSE.results.optimization orelse OPTIMIZATION
    this.version      = if ARGPARSE.results.version      isnot null then ARGPARSE.results.version orelse VERSION
    this.debug        = if ARGPARSE.results.no_debug     then NODEBUG orelse DEBUG
    this.rpath        = if ARGPARSE.results.no_rpath     then NORPATH orelse RPATH

    if this.install_script is false and ARGPARSE.results.all then this.install_script = true

    if ARGPARSE.results.libdir  isnot null then this.set.libdir  (ARGPARSE.results.libdir)
    if ARGPARSE.results.incdir  isnot null then this.set.incdir  (ARGPARSE.results.incdir)
    if ARGPARSE.results.bindir  isnot null then this.set.bindir  (ARGPARSE.results.bindir)
    if ARGPARSE.results.moddir  isnot null then this.set.moddir  (ARGPARSE.results.moddir)
    if ARGPARSE.results.datadir isnot null {
      this.set.datadir (ARGPARSE.results.datadir)
      this.set.shelldatadir (ARGPARSE.results.datadir: concat_with (SHELL + "/commands"))
    }

    if ARGPARSE.results.dump_commands is true then this.set.dump_commands (true)

    if ARGPARSE.results.local_spec is true {
      SPECNAME = LOCAL_SPEC
      CACHEDNAME = LOCAL_CACHED
    }

    return ifnot ARGPARSE.results.force

    if ARGPARSE.results.shared or ARGPARSE.results.shared_library    or ARGPARSE.results.all then this.force_shared_library = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_module     or ARGPARSE.results.all then this.force_shared_module = true
    if ARGPARSE.results.shared or ARGPARSE.results.shared_executable or ARGPARSE.results.all then this.force_shared_executable = true
    if ARGPARSE.results.static or ARGPARSE.results.static_library    or ARGPARSE.results.all then this.force_static_library = true
    if ARGPARSE.results.static or ARGPARSE.results.static_executable or ARGPARSE.results.all then this.force_static_executable = true
    if ARGPARSE.results.shared or ARGPARSE.results.static            or ARGPARSE.results.install_header or ARGPARSE.results.all then this.force_header = true
    if ARGPARSE.results.all    or ARGPARSE.results.install_script    then this.force_script = true
  }

  record : func (sources) {
    if this.recorded is null then this.recorded = {}

    for v in sources {
      continue if key_exists (this.recorded, v)
      continue ifnot v: exists ()
      var st = v: stat ()
      var base = base64_encode (v)
      this.recorded.$(v) = { mtime : st.st_mtime, base : base }
    }

    var v = SPECNAME
    var st = v: stat ()
    var base = base64_encode (v)
    this.recorded.$(v) = { mtime : st.st_mtime, base : base }
  }

  read_cached_file : func {
    if this.cached is null {
      var fd = open (this.cached_file, O_RDONLY, 0)
      return true if fd is null

      var s = read (fd)
      var r = eval (s)
      if r isnot ok {
        println ("${this.cached_file}: evaluation error")
        return notok
      }
    }

    return false
  }

  should_make : func (target, sources, force) {
    return true if force

    var type = target: typeof ()
    if type is ArrayType or type is ListType {
      for v in target return true ifnot v: exists ()
    } else {
      return true ifnot target: exists ()
    }

    return true ifnot this.cached_file: exists ()

    var r = this.read_cached_file ()
    return notok if r is notok
    return true  if r is true

    for v in sources {
      return true ifnot this.cached:   key_exists (v)
      return true ifnot this.recorded: key_exists (v)

      return true if this.cached.$(v).mtime isnot this.recorded.$(v).mtime
      return true if this.cached.$(v).base  isnot this.recorded.$(v).base
    }

    var v = SPECNAME

    return true ifnot this.cached:   key_exists (v)
    return true ifnot this.recorded: key_exists (v)
    return true if    this.cached.$(v).mtime isnot this.recorded.$(v).mtime

    return false
  }

  install_data : func (exec) {
    return ok if null is exec
    return notok if notok is this.change_to_build_directory ()

    var targetdir = this.shelldatadir: concat_with (exec)
    ifnot targetdir: exists () then mkdir (targetdir, 0700)
    ifnot targetdir: isdirectory () {
      println ("${targetdir}: not a directory")
      return notok
    }

    ifnot this.verbose then
      ifnot this.dump_commands then
        println ("  install data")

    var args = exec: concat_with ("args")
    if args: exists () then
      copy (args, targetdir; verbose : this.verbose + 1, force : 1)

    var flags = exec: concat_with ("flags")
    if flags: exists () then
      copy (flags, targetdir; verbose : this.verbose + 1, force : 1)

    var literal_args = exec: concat_with ("literal_args")
    if literal_args: exists () then
      copy (literal_args, targetdir; verbose : this.verbose + 1, force : 1)
  }

  endbuild : func (retval) {
    change (this.curdir)
    this.retval = retval
    return retval
  }

  init : func (unit, targets) {
    var name = qualifier ("name", null)

    var is_z_ns = qualifier_exists ("from_z_namespace")

    this.targets = targets

    var dir = unit: dirname ()

    if null is name {
      if this.local_env and is_z_ns {
        var base_name = dir: dirname (): basename ()
        name = (char (base_name[0] + ('a' - 'A')) + advance (base_name, 1)
      } else {
        name =  dir: basename ()
      }
    }

    this.name = name

    this.curdir = Dir.current ()

    this.set_options ()

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      this.set.shared.executable.to_linkagainst (this.name + "-" + this.version)

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      this.set.static.executable.to_linkagainst (this.name + "-" + this.version)

    if this.targets & MODULE and (this.targets & SHARED_LIBRARY or this.targets & SHARED) then
      this.set.shared.module.to_linkagainst (this.name + "-" + this.version)

    this.set.libname                          (name)
    this.set.liboutput                        (name)
    this.set.builddir                         (dir)
    this.set.header                           (name + ".h")
    this.set.cached_file                      (this.builddir: concat_with (CACHEDNAME))
    this.set.shared.library.source            ("lib" + name + ".c")
    this.set.shared.module.source             (name + "-module.c")
    this.set.static.library.source            ("lib" + name + ".c")
    this.set.execoutput                       (char (name[0] - ('a' - 'A')) + advance (name, 1))
    this.set.script.source                    (char (name[0] - ('a' - 'A')) + advance (name, 1))
    this.set.shared.executable.source         (name + "_main.c")
    this.set.shared.module.output             (name)
    this.set.static.executable.source         (name + "_main.c")

    this.init_local_cflags ()
    this.init_include_dirs ()
    this.init_lib_dirs ()
    this.init_cflags ()
  }

  append_value : func (v, l) {
    return if null is v
    var t =  v: typeof ()
    if t is ArrayType then
      for f in v append f in l
    orelse
      if t is StringType then append v in l
  }

  append_linkagainst_value : func (v, l) {
    return if null is v
    var t =  v: typeof ()
    if t is ArrayType then
      for f in v append "-l" + f in l
    orelse
      if t is StringType then append "-l" + v in l
  }

  make_objects_build_dir : func {
    ifnot "build": exists () then mkdir ("build", 0700)
    ifnot "build": isdirectory () {
      if false is this.dump_commands {
        println ("build: is not a directory")
        return notok
      }
    }

    return ok
  }

  shared_library_compile_objects : func {
    return notok if notok is this.make_objects_build_dir ()

    var com = this.cc + " -std=" + this.std

    append " " + this.march        in com
    append " " + this.optimization in com

    for v in this.cflags if v isnot null append " " + v in com

    append " -shared -fPIC" in com

    var string[this.shared_library_sources: len ()] objects

    for i, v in this.shared_library_sources {
      var oo = "build/" + v: path_basename_sans_extname () + ".o"
      objects[i] = oo
    }

    var n = 0

    var r
    for i, v in objects {
      r = this.should_make (v, [this.shared_library_sources[i]], this.force_shared_library)
      return notok if r is notok
      continue if r is false
      n++
      var lcom = com + " -c " + this.shared_library_sources[i] + " -o " + v

      if this.dump_commands {
        println (lcom)
        continue
      }

      if this.verbose then println (lcom)

      r = this.sh: exec (lcom)
      if r is notok {
        ifnot this.verbose then println (lcom)
        println ("failed")
        return notok
      }
    }

    return ok ifnot n

    for v in this.shared_library.cflags       if v isnot null append " " + v in com
    for v in this.linkagainst.shared_library  if v isnot null append " " + v in com

    if this.rpath then append " -Wl,-rpath=" + this.libdir in com

    for v in objects append " " + v in com

    var output = this.libdir: concat_with (this.liboutput + ".so")
    append " -o " + output in com

    if this.verbose then println (com)

    r = this.sh: exec (com)
    if r isnot ok {
      ifnot this.verbose then println (com)
      println ("failed")
      return notok
    }

    return this.endbuild (if r isnot ok then notok orelse ok end)
  }

  static_library_compile_objects : func {
    return notok if notok is this.make_objects_build_dir ()

    var com = this.cc + " -std=" + this.std

    append " " + this.march        in com
    append " " + this.optimization in com

    if this.cc isnot "tcc" then append " -z muldefs" in com

    for v in this.cflags if v isnot null append " " + v  in com
    if this.rpath then append " -Wl,-rpath=" + this.libdir in com
    append " -DSTATIC -static" in com

    if this.cc isnot "tcc" then append " -z muldefs" in com

    var string[this.static_library_sources: len ()] objects

    for i, v in this.static_library_sources {
      var oo = "build/" + (v: path_basename_sans_extname ()) + ".o"
      objects[i] = oo
    }

    var n = 0

    var r
    for i, v in objects {
      r = this.should_make (v, [this.static_library_sources[i]], this.force_static_library)
      return notok if r is notok
      continue if r is false
      n++
      var lcom = com + " -c " + this.static_library_sources[i] + " -o " + v

      if this.dump_commands {
        println (lcom)
        continue
      }

      if this.verbose then println (lcom)

      r = this.sh: exec (lcom)
      if r is notok {
        ifnot this.verbose then println (lcom)
        println ("failed")
        return notok
      }
    }

    return ok ifnot n

    var output = this.libdir: concat_with (this.liboutput + ".a")

    com = "ar rs " + output

    for v in objects append " " + v in com

    if this.verbose then println (com)
    r = this.sh: exec (com)

    r = this.sh: exec (com)
    if r is notok {
      ifnot this.verbose then println (com)
      println ("failed")
      return notok
    }

    remove ("build/" + this.liboutput + ".o")

    return this.endbuild (ok)
  }

  public
  main : func {
    return ok if this.targets is IGNORE

    if this.targets & PACKAGE {
      var p = New Packman ()
      p.set.builddir (TMPDIR)
      p.new.spec (this.name)
      return notok if notok is p.build ()
    }

    if this.targets & LIBC
      return this.make.libc ()

    if this.targets & SHARED_LIBRARY or this.targets & SHARED or
       this.targets & STATIC_LIBRARY or this.targets & STATIC
      return notok if this.install.header () is notok

    if this.targets & SHARED_LIBRARY or this.targets & SHARED then
      return notok if this.make.shared.library () is notok

    if this.targets & SHARED_EXECUTABLE or this.targets & SHARED then
      return notok if this.make.shared.executable () is notok

    if this.targets & STATIC_LIBRARY or this.targets & STATIC then
      return notok if this.make.static.library () is notok

    if this.targets & STATIC_EXECUTABLE or this.targets & STATIC then
      return notok if this.make.static.executable () is notok

    if this.targets & MODULE then
      return notok if this.make.shared.module () is notok

    if this.targets & SCRIPT then
      return notok if this.install.script () is notok

    return ok
  }

  write_record : func {
    return ok if null is this.recorded

    var fd = open (this.cached_file, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR)
    return notok if fd is null

    return notok if notok is write (fd, "this.cached = {\n")

    for k, v in this.recorded {
      return notok if notok is write (fd, "  \"" + k + "\" : {\n    mtime : ")
      return notok if notok is write (fd, format ("${v.mtime}"))
      return notok if notok is write (fd, "\n    base : \"" + v.base + "\"\n")
      return notok if notok is write (fd, "  }\n")
    }

    return write (fd, "}")
  }

  get : {
    version                  : func return this.version
    retval                   : func return this.retval
    dependencies             : func return this.dependencies
    name                     : func return this.name
    dump_commands            : func return this.dump_commands
    libdir                   : func return this.libdir
    toplibdir                : func return this.toplibdir
    targets                  : func return this.targets
  }

  set : {
    cc                       : func (c) ifnot null is c this.cc = c
    std                      : func (s) ifnot null is s this.std = s
    march                    : func (m) ifnot null is m this.march = m
    version                  : func (v) ifnot null is v this.version = v
    libname                  : func (l) ifnot null is l this.libname = l
    liboutput                : func (o) ifnot null is o this.liboutput = "lib" + o + "-" + this.version
    execoutput               : func (o) ifnot null is o this.execoutput = o
    optimization             : func (o) ifnot null is o this.optimization = o
    header                   : func (h) ifnot null is h this.header = h
    cached_file              : func (c) ifnot null is c this.cached_file = c
    builddir                 : func (d) ifnot null is d this.builddir = d
    bindir                   : func (d) ifnot null is d this.bindir = d
    libdir                   : func (d) ifnot null is d this.libdir = d
    incdir                   : func (d) ifnot null is d this.incdir = d
    moddir                   : func (d) ifnot null is d this.moddir = d
    datadir                  : func (d) ifnot null is d this.datadir = d
    shelldatadir             : func (d) ifnot null is d this.shelldatadir = d

    dump_commands            : func (v) this.dump_commands = v

    local_env                : func (b) {
      this.local_env = b
      if this.local_env is false then this.local_cflags = false
    }

    modulesdirname           : func (n) {
      return if null is n
      if this.local_env is false then this.modulesdirname = n
      orelse
        if Y is n then this.modulesdirname = "l-modules"
        orelse
          if  Z is n then this.modulesdirname = "la-modules"
          orelse this.modulesdirname = n
    }

    namespace                : func (n) {
      return if null is n
      return if this.namespace is n
      this.namespace = n
      this.set.libdir (LIBDIR: concat_with (this.namespace))
      this.set.incdir (INCDIR: concat_with (this.namespace))
      this.set.modulesdirname (n)
    }

    cflags                   : func (v) this.append_value (v, this.cflags)

    shared : {
      library : {
        to_linkagainst       : func (l) this.append_linkagainst_value (l, this.linkagainst.shared_library)
        cflag                : func (v) this.append_value (v, this.shared_library.cflags)
        source               : func (v) {
          if qualifier_exists ("clear") then
            this.clear.shared.library.sources ()
          this.append_value (v, this.shared_library_sources)
        }

        compile_type         : func (t) this.shared_library_compile_type = t
      }

      executable : {
        to_linkagainst       : func (l) this.append_linkagainst_value (l, this.linkagainst.shared_executable)
        cflag                : func (v) this.append_value (v, this.shared_executable.cflags)
        source               : func (v) {
          if qualifier_exists ("clear") then
            this.clear.shared.executable.sources ()
          this.append_value (v, this.shared_executable_sources)
        }
      }

      module : {
        to_linkagainst       : func (l) this.append_linkagainst_value (l, this.linkagainst.shared_module)
        cflag                : func (v) this.append_value (v, this.shared_module.cflags)
        output               : func (o) ifnot null is o this.moduleoutput = o
        source               : func (v) {
          if qualifier_exists ("clear") then
            this.clear.shared.module.sources ()
          this.append_value (v, this.shared_module_sources)
        }
      }

      cflags                 : func (v) {
        this.set.shared.library.cflag (v) this.set.shared.executable.cflag (v)
      }
    }

    static : {
      library : {
        to_linkagainst       : func (l) this.append_linkagainst_value (l, this.linkagainst.static_library)
        cflag                : func (v) this.append_value (v, this.static_library.cflags)
        source               : func (v) {
          if qualifier_exists ("clear") then
            this.clear.static.library.sources ()
          this.append_value (v, this.static_library_sources)
        }
        compile_type         : func (t) this.static_library_compile_type = t
      }

      executable : {
        to_linkagainst       : func (l) this.append_linkagainst_value (l, this.linkagainst.static_executable)
        cflag                : func (v) this.append_value (v, this.static_executable.cflags)
        source               : func (v) {
          if qualifier_exists ("clear") then
            this.clear.static.executable.sources ()
          this.append_value (v, this.static_executable_sources)
        }
      }

      cflags                 : func (v) {
        this.set.static.library.cflag (v) this.set.static.executable.cflag (v)
      }
    }

    script : {
      source                 : func (v) {
        if qualifier_exists ("clear") then
          this.clear.script.sources ()
        this.append_value (v, this.script_sources)
      }

      interpr : func (s, interpr) {
        if null is this.script_interpr then
          this.script_interpr = { $(s) : interpr }
        orelse
          this.script_interpr.$(s) = interpr
      }
    }

    libc : {
      source               : func (v) {
        if qualifier_exists ("clear") then
          this.clear.libc.sources ()
        this.append_value (v, this.libc_sources)
      }
    }

    library : {
      cflag                  : func (v) {
        this.set.shared.library.cflag (v) this.set.static.library.cflag (v)
      }
    }

    executable : {
      cflags                 : func (v) {
        this.set.shared.executable.cflag (v) this.set.static.executable.cflag (v)
      }
    }

  }

  reset : {
    executable : {
      sources : {
        with                 : func (v) {
          ifnot null is v {
            this.clear.shared.executable.sources ()
            this.clear.static.executable.sources ()
            this.set.shared.executable.source (v)
            this.set.static.executable.source (v)
          }
        }
      }
    }
  }

  clear : {
    cflags                   : func clear (this.cflags)

    shared : {
      library : {
        to_linkagainst       : func clear (this.linkagainst.shared_library)
        cflags               : func clear (this.shared_library.cflags)
        sources              : func clear (this.shared_library_sources)
      }

      module : {
        to_linkagainst       : func clear (this.linkagainst.shared_module)
        cflags               : func clear (this.shared_module.cflags)
        sources              : func clear (this.shared_module_sources)
      }

      executable : {
        to_linkagainst       : func clear (this.linkagainst.shared_executable)
        cflags               : func clear (this.shared_executable.cflags)
        sources              : func clear (this.shared_executable_sources)
      }
    }

    static : {
      library : {
        to_linkagainst       : func clear (this.linkagainst.static_library)
        cflags               : func clear (this.static_library.cflags)
        sources              : func clear (this.static_library_sources)
      }

      executable : {
        to_linkagainst       : func clear (this.linkagainst.static_executable)
        cflags               : func clear (this.static_executable.cflags)
        sources              : func clear (this.static_executable_sources)
      }
    }

    script : { sources       : func clear (this.script_sources) }

    libc   : { sources       : func clear (this.libc_sources) }
  }

  filter: {
    shared : {
      executable : {
        to_linkagainst  : func (f) {
          for i, v in this.linkagainst.shared_executable  {
            if v is f then list_delete_at (this.linkagainst.shared_executable, i)
          }
        }
      }
    }

    static : {
      executable : {
        to_linkagainst      : func (f) {
          for i, v in this.linkagainst.static_executable  {
            if v is f then list_delete_at (this.linkagainst.static_executable, i)
          }
        }
      }
    }
  }

  unset : { rpath : func this.rpath = NORPATH }

  install : {
    header : func {
      return notok if notok is this.change_to_build_directory () and this.dump_commands is false

      this.record ([this.header])

      return ok if false is this.install_header
      return ok if null is this.header

      ifnot this.incdir: exists () then mkdir (this.incdir, 0755; verbose : this.verbose + 1)
      ifnot this.incdir: isdirectory () {
        if false is this.dump_commands {
          println ("${this.incdir}: is not a directory")
          return notok
        }
      }

      var to = this.incdir: concat_with (this.header);

      var r = this.should_make (to, [this.header], this.force_header)
      return notok if r is notok
      return ok if r is false

      if this.dump_commands {
        var ver = "-v "
        println ("# installing C header")
        println ("cp ${%s, this.verbose: if v is 1 then ver orelse `` end}--force ${this.header} ${to}")
        return ok
      }

      r = copy (this.header, to; verbose : this.verbose + 1, force : 1)
      this.install_header = false
      return this.endbuild (r)
    }

    script : func {
      return ok if this.dump_commands
      return notok if notok is this.change_to_build_directory ()
      return ok if null is this.script_sources

      var sources = {[]}
      for v in this.script_sources append v + ".lai" in sources

      this.record (sources)

      return ok if false is this.install_script

      ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
      ifnot this.bindir: isdirectory () {
        if false is this.dump_commands {
          println ("${this.bindir}: is not a directory")
          return notok
        }
      }

      var targets = {[]}

      for v in this.script_sources {
        append this.bindir: concat_with (v)             in targets
        append this.bindir: concat_with (v) + "-static" in targets
      }

      var r = this.should_make (targets, sources, this.force_script)

      return notok if r is notok
      return ok if r is false

      r = notok
      var idx = 0
      for v in sources {
        continue ifnot v: exists ()

        var read_fd = open (v, O_RDONLY, 0)
        continue if null is read_fd
        var script = read (read_fd)

        var interpr = SCRIPT_INTERPRETER

        ifnot null is this.script_interpr {
          var vv = v: path_basename_sans_extname ()
          for u, i in this.script_interpr {
            if u is vv {
              interpr = i
              break
            }
          }
        }

        var output = targets[idx++]

        var write_fd = open (output, O_WRONLY|O_CREAT, S_IRWXU);

        ifnot null is write_fd { 
          if this.verbose then println ("install ${output}") orelse println ("  install scripts")
          write (write_fd, "#!/bin/env " + interpr + "\n\n")
          write (write_fd, script)
          r = ok
        }

        output = targets[idx++]
        write_fd  = open (output, O_WRONLY|O_CREAT, S_IRWXU)
        ifnot null is write_fd {
          if this.verbose then println ("install ${output}")
          write (write_fd, "#!/bin/env La-static\n\n")
          write (write_fd, script)
          r = ok
        }
      }

      if r is ok then
        for v in this.script_sources this.install_data (v)

      return this.endbuild (r)
    }
  }

  make : {
    shared : {
      library : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared_library_sources)

        return ok if false is this.make_shared_library

        return notok if this.shared_library_compile_type < COMPILE_ASSEMBLE_LINK or
           this.shared_library_compile_type > COMPILE_ASSEMBLE

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.libdir}: is not a directory")
            return notok
          }
        }

        if this.shared_library_compile_type is COMPILE_ASSEMBLE then
          return this.shared_library_compile_objects ()

        var output = this.libdir: concat_with (this.liboutput + ".so")
        var r = this.should_make (output, this.shared_library_sources, this.force_shared_library)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                      if v isnot null append " " + v in com
        for v in this.shared_library.cflags       if v isnot null append " " + v in com
        for v in this.linkagainst.shared_library  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir      in com

        append " -shared -fPIC" in com
        append " -o " + output  in com

        for v in this.shared_library_sources if v isnot null then append " " + v in com

        if this.dump_commands {
          println ("# making the shared library")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the shared library")

        r = this.sh: exec (com)

        var to = this.libdir: concat_with ("lib" + this.libname + ".so")
        if ok is r then
          symlink (this.liboutput + ".so", to; verbose : this.verbose + 1, force : 1)

        this.make_shared_library = false

        if r isnot ok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }

      executable : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared_executable_sources)

        return ok if false is this.make_shared_executable

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
        ifnot this.bindir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.bindir}: is not a directory")
            return notok
          }
        }

        var output = this.bindir: concat_with (this.execoutput + "-shared")

        var r = this.should_make (output, this.shared_executable_sources, this.force_shared_executable)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                         if v isnot null append " " + v in com
        for v in this.shared_executable.cflags       if v isnot null append " " + v in com
        for v in this.linkagainst.shared_executable  if v isnot null append " " + v in com

        if this.rpath then append " -Wl,-rpath=" + this.libdir in com

        append " -o " + output in com

        for v in this.shared_executable_sources if v isnot null then append " " + v in com

        if this.dump_commands {
          println ("# making the shared executable")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the shared executable")

        r = this.sh: exec (com)

        var to = this.bindir: concat_with (this.execoutput)

        if ok is r {
          symlink (this.execoutput + "-shared", to; verbose : this.verbose + 1, force : 1)
          this.install_data (this.execoutput)
        }

        this.make_shared_executable = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }

      module : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.shared_module_sources)

        return ok if false is this.make_shared_module

        ifnot this.moddir: exists () then mkdir (this.moddir, 0755; verbose : this.verbose + 1)
        ifnot this.moddir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.moddir}: is not a directory")
            return notok
          }
        }

        var instdir = this.libdir: concat_with (this.modulesdirname)
        ifnot instdir: exists () then mkdir (instdir, 0755; verbose : this.verbose + 1)
        ifnot instdir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.moddir}: is not a directory")
            return notok
          }
        }

        var output = instdir: concat_with (this.moduleoutput + "-module.so")

        var r = this.should_make (output, this.shared_module_sources, this.force_shared_module)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        append " " + this.march        in com
        append " " + this.optimization in com

        for v in this.cflags                     if v isnot null append " " + v in com
        for v in this.shared_module.cflags       if v isnot null append " " + v in com
        for v in this.linkagainst.shared_module  if v isnot null append " " + v in com

        append " -shared -fPIC" in com
        append " -lla -lstring -lvmap -lvstring" in com
        append " -o " + output in com

        for v in this.shared_module_sources if v isnot null then append " " + v in com

        if this.dump_commands {
          println ("# making the shared module")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the shared module")

        r = this.sh: exec (com)

        this.make_shared_module = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }
    }

    static : {
      library : func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.static_library_sources)

        return ok if false is this.make_static_library

        return notok if this.static_library_compile_type < COMPILE_ASSEMBLE_LINK or
           this.static_library_compile_type > COMPILE_ASSEMBLE

        ifnot this.libdir: exists () then mkdir (this.libdir, 0755; verbose : this.verbose + 1)
        ifnot this.libdir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.libdir}: is not a directory")
            return notok
          }
        }

        if this.static_library_compile_type is COMPILE_ASSEMBLE then
          return this.static_library_compile_objects ()

        var output = this.libdir: concat_with (this.liboutput + ".a")

        var r = this.should_make (output, this.static_library_sources, this.force_static_library)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        for v in this.static_library_sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com

        if this.cc isnot "tcc" then append " -z muldefs" in com

        for v in this.cflags                     if v isnot null append " " + v in com
        for v in this.static_library.cflags      if v isnot null append " " + v in com
        for v in this.linkagainst.static_library if v isnot null append " " + v in com

        append " -DSTATIC"                    in com
        append " -static -c"                  in com
        append " -o " + this.liboutput + ".o" in com

        if this.dump_commands {
          println ("# making the static library")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the static library")

        r = this.sh: exec (com)

        if ok is r {
          com = "ar rs " + output
          append " " + this.liboutput + ".o" in com
          if this.verbose then println (com)
          r = this.sh: exec (com)
          remove (this.liboutput + ".o")
        }

        this.make_static_library = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }

      executable: func {
        return notok if notok is this.change_to_build_directory () and this.dump_commands is false

        this.record (this.static_executable_sources)

        return ok if false is this.make_static_executable

        ifnot this.bindir: exists () then mkdir (this.bindir, 0755; verbose : this.verbose + 1)
        ifnot this.bindir: isdirectory () {
          if false is this.dump_commands {
            println ("${this.bindir}: is not a directory")
            return notok
          }
        }

        var output = this.bindir: concat_with (this.execoutput + "-static")

        var r = this.should_make (output, this.static_executable_sources, this.force_static_executable)
        return notok if r is notok
        return ok if r is false

        var com = this.cc + " -std=" + this.std

        for v in this.static_executable_sources if v isnot null then append " " + v in com

        append " " + this.march        in com
        append " " + this.optimization in com
        append " -DSTATIC"             in com
        append " -static"              in com

        if this.cc isnot "tcc" then append " -z muldefs" in com

        for v in this.cflags                        if v isnot null append " " + v in com
        for v in this.static_executable.cflags      if v isnot null append " " + v in com
        for v in this.linkagainst.static_executable if v isnot null append " " + v in com

        append " -o " + output in com

        if this.dump_commands {
          println ("# making the static executable")
          println (com)
          return ok
        }

        if this.verbose then println (com) orelse println ("  making the static executable")

        r = this.sh: exec (com)
        if r is ok
          this.install_data (output)

        this.make_static_executable = false

        if r is notok println ("  failed") orelse
          ifnot this.verbose then println ("  done")

        return this.endbuild (if r isnot ok then notok orelse ok end)
      }
    }

    libc : func {
      return notok if notok is this.change_to_build_directory ()
      return notok ifnot this.libc_sources: len ()

      this.record (this.libc_sources)

      var force = ARGPARSE.results.force

      var outputDir = YSRCPKGDIR: concat_with (LIBCNAME)
      var output = outputDir: concat_with (LIBCNAME + ".c")

      var r = this.should_make (output, this.libc_sources, force)

      return notok if r is notok
      return ok if r is false

      include ("generateLibc")

      var argv = ["", "--outputName=" + LIBCNAME, "--outputDir=" + outputDir] 
      if this.verbose then println ("installing libc at ${output}")

      return libc_generate (3, argv);
    }
  }
}


const DEPENDENCIES = {}

func make_dependencies (f) {

  func get_dep_spec (d) {
    var p = d
    ifnot d: exists () {
      var n = JSRCPKGDIR: concat_with(d)
      ifnot n: exists () {
        n = YSRCPKGDIR: concat_with (d)
        ifnot n: exists () {
          n = ZSRCLIBDIR: concat_with (d): concat_with ("src")
          ifnot n: exists () {
            n = ZSRCAPPDIR: concat_with (d): concat_with ("src")
            return null ifnot n: exists ()
          }
        }
      }

      p = n
    }

    var file =
      if p: isdirectory () then p: concat_with (SPECNAME): realpath ()
      orelse p: realpath ()

    return null ifnot file: exists ()
    return file
  }

  const Dependencies = {}
  const TARGETS      = {}

  func append_target (d, targets) {

    if TARGETS: key_exists (d) {
      TARGETS.$(d).targets |= targets
    } else {
      var k = get_dep_spec (d)
      append { targets : targets, initializedAs : k } in TARGETS as d
    }

    if TARGETS.$(d).initializedAs isnot null  {
      var t = TARGETS.$(d).initializedAs
      if DEPENDENCIES: key_exists (t) then
        DEPENDENCIES.$(t).targets |= targets
    }
  }

  func get_dependencies (dir) {
    var file = get_dep_spec (dir)
    return notok if file is null

    return ok if DEPENDENCIES: key_exists (file)

    var dlen = DEPENDENCIES: len ()

    append { id : dlen + 1, targets : 0 } in DEPENDENCIES as file

    append { deps : string[0], targets : integer[0] } in Dependencies as file

    var bname = dir: basename ()
    if TARGETS: key_exists (bname)
      DEPENDENCIES.$(file).targets = TARGETS.$(bname).targets

    var fd = open (file, O_RDONLY, 0)

    return notok if fd is null

    var s = read (fd)

    var an = annotate_get (s)
    return notok if an is null

    return ok ifnot len (s)

    func depends_on (dep, targets) {
      ifnot null is dep {
        for k, v in Dependencies {
          for d in v.deps {
            if dep is d {
              append_target (d, targets)
              return ok
            }
          }
        }

        append dep in Dependencies.$(file).deps

        append_target (dep, targets)
      }
    }

    return notok if notok is eval (an)

    return ok ifnot len (Dependencies.$(file).deps)

    for d in Dependencies.$(file).deps {
      if d isnot null then
        return notok if notok is get_dependencies (d)
    }

    return ok
  }

  get_dependencies (f)
}

  # main
  ARGPARSE = argparseNew ()

  return notok ifnot ok is ARGPARSE.process (argv, 1)
  return ok if ARGPARSE.exit is true

  var pkg = ifnot ARGPARSE.argc then Dir.current () orelse ARGPARSE.argv[0]

  var FORCE       = ARGPARSE.results.force
  var RECUR       = ARGPARSE.results.recursive
  var SHARED_ALL  = ARGPARSE.results.shared
  var SHARED_LIB  = ARGPARSE.results.shared_library
  var SHARED_EXE  = ARGPARSE.results.shared_executable
  var SHARED_MOD  = ARGPARSE.results.shared_module
  var STATIC_ALL  = ARGPARSE.results.static
  var STATIC_LIB  = ARGPARSE.results.static_library
  var STATIC_EXE  = ARGPARSE.results.static_executable
  var INST_SCRIPT = ARGPARSE.results.install_script
  var DO_ALL      = ARGPARSE.results.all
  var verbose     = ARGPARSE.results.verbose

  # do it twice as the time that is properly set, it might be already late
  if ARGPARSE.results.local_spec is true {
    SPECNAME = LOCAL_SPEC
    CACHEDNAME = LOCAL_CACHED
  }

  func zero_argparse_results () {
    ARGPARSE.results.shared            = false
    ARGPARSE.results.static            = false
    ARGPARSE.results.force             = false
    ARGPARSE.results.recursive         = false
    ARGPARSE.results.shared_library    = false
    ARGPARSE.results.shared_executable = false
    ARGPARSE.results.shared_module     = false
    ARGPARSE.results.static_library    = false
    ARGPARSE.results.static_executable = false
    ARGPARSE.results.install_script    = false
    ARGPARSE.results.all               = false
  }

  func init_argparse_results (flag, is_the_last) {
    if is_the_last {
      ARGPARSE.results.force             = FORCE
      ARGPARSE.results.recursive         = RECUR
      ARGPARSE.results.shared            = SHARED_ALL
      ARGPARSE.results.shared_library    = SHARED_LIB
      ARGPARSE.results.shared_executable = SHARED_EXE
      ARGPARSE.results.shared_module     = SHARED_MOD
      ARGPARSE.results.static            = STATIC_ALL
      ARGPARSE.results.static_library    = STATIC_LIB
      ARGPARSE.results.static_executable = STATIC_EXE
      ARGPARSE.results.install_script    = INST_SCRIPT
      ARGPARSE.results.all               = DO_ALL
      return
    }

    zero_argparse_results ()

    if FORCE then
      if RECUR then
        ARGPARSE.results.force = true

    ARGPARSE.results.shared         = if flag & SHARED or flag & ALL then true orelse false
    ARGPARSE.results.shared_library = if flag & SHARED_LIBRARY or flag & ALL  then true orelse false
    ARGPARSE.results.shared_module  = if flag & MODULE or flag & ALL          then true orelse false
    ARGPARSE.results.static         = if flag & STATIC or flag & ALL          then true orelse false
    ARGPARSE.results.static_library = if flag & STATIC_LIBRARY or flag & ALL  then true orelse false
    ARGPARSE.results.install_script = if flag & SCRIPT or flag & ALL         then true orelse false
  }

  return notok if notok is make_dependencies (pkg)

  var dlen = DEPENDENCIES: len ()
  var deps = string[dlen]

  for k, v in DEPENDENCIES deps[dlen - v.id] = k

  var retval = ok

  ifnot deps: len () {
    println ("${pkg} package: not found")
    exit (1)
  }

  for i, v in deps {
    return notok ifnot v: exists ()

    var is_the_last = i is (dlen - 1)

    init_argparse_results (DEPENDENCIES.$(v).targets, is_the_last)

    var r = ok
    var s = evalfile (v)

    if null is s {
      r = notok
      print ("# Making: [ ${dirname (v): basename ()} ]")
    } else {
      ifnot s.get.targets () is IGNORE then
        println ("# Making: [\e[33m ${s.get.name ()} \e[m]")
      r =  s.main ()
    }

    if r isnot ok then println (" \e[31mfailed\e[m")
    orelse
      ifnot verbose then
        ifnot s.get.targets () is IGNORE then
          ifnot s.get.dump_commands then println ("\e[32mdone\e[m")

    return notok if r isnot ok

    s.write_record ()

    if notok is s.get.retval () then retval = notok
  }

  return retval
}

var r = Make (__argc, __argv)

exit (if r is ok then 0 orelse 1)

#####################
#  at the end (at least) funcrefs callbacks
#
